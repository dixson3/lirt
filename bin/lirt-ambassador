#!/usr/bin/env bash
# lirt-ambassador - Multi-gastown coordination
#
# Usage: lirt-ambassador <command> [args]
#
# Commands:
#   init              Initialize this gastown (UUID, capabilities, policies)
#   id                Get town UUID
#   alias             Get town alias (hostname.overseer)
#   whoami            Show full identity
#   caps <subcommand> Manage capabilities (list, add, remove)
#   policy <subcommand> Manage policies
#   status            Show current gastown status
#   assess <issue>    Check if this gastown can handle an issue
#   route <issue>     Route issue to appropriate gastown
#   create            Create a policy-qualified bead
#   classify <issue>  Add policy classification to existing bead
#   quarantine        List beads without policy classification
#   ready             List policy-qualified beads ready for work
#   approvals         List beads awaiting approval
#   approve <issue>   Approve a held bead
#   deny <issue>      Deny a held bead
#   migrate           Migrate from v1 config format
#   sync-setup        Set up the beads sync branch

set -euo pipefail

# Find the current git project root (for sync branch operations)
find_git_root() {
    git rev-parse --show-toplevel 2>/dev/null || {
        echo "Error: Not in a git repository" >&2
        return 1
    }
}

# Gas Town root (for shared town config)
# Uses GT_ROOT if set, otherwise falls back to git root
GASTOWN_ROOT="${GT_ROOT:-}"
if [[ -z "$GASTOWN_ROOT" ]]; then
    GASTOWN_ROOT=$(find_git_root) || exit 1
fi

# Project root (current git repo - for sync branch)
PROJECT_ROOT=$(find_git_root) || exit 1

# Ambassador config is at Gas Town level (shared across projects)
AMBASSADOR_DIR="$GASTOWN_ROOT/.ambassador"
TOWN_CONFIG="$AMBASSADOR_DIR/town.json"
SYNC_BRANCH="${AMBASSADOR_SYNC_BRANCH:-beads-sync}"

# Ensure jq is available
check_deps() {
    if ! command -v jq &> /dev/null; then
        echo "Error: jq is required. Install with: brew install jq" >&2
        exit 1
    fi
}

# Generate UUID v4
generate_uuid() {
    # Try various methods to generate UUID
    if command -v uuidgen &> /dev/null; then
        uuidgen | tr '[:upper:]' '[:lower:]'
    elif [[ -f /proc/sys/kernel/random/uuid ]]; then
        cat /proc/sys/kernel/random/uuid
    else
        # Fallback: generate pseudo-UUID using /dev/urandom
        od -x /dev/urandom | head -1 | awk '{
            printf "%s%s-%s-%s-%s-%s%s%s\n", $2,$3,$4,substr($5,1,1)"4"substr($5,3,2),
            substr($6,1,1)$7,substr($6,3,2),$8,$9
        }' | tr '[:upper:]' '[:lower:]' | head -c 36
        echo
    fi
}

# Get hostname (short form)
get_hostname() {
    hostname -s 2>/dev/null || hostname 2>/dev/null | cut -d. -f1
}

# Get current user (overseer)
get_overseer() {
    whoami 2>/dev/null || echo "${USER:-unknown}"
}

# Detect OS capability
detect_os() {
    case "$(uname -s)" in
        Darwin) echo "darwin" ;;
        Linux) echo "linux" ;;
        MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
        *) echo "unknown" ;;
    esac
}

# Detect architecture capability
detect_arch() {
    case "$(uname -m)" in
        x86_64|amd64) echo "amd64" ;;
        arm64|aarch64) echo "arm64" ;;
        armv7l) echo "arm" ;;
        *) echo "$(uname -m)" ;;
    esac
}

# Check if config uses v2 format (has UUID)
is_v2_config() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        return 1
    fi
    # V2 has 'alias' field and UUID-formatted id
    local id
    id=$(jq -r '.id // ""' "$TOWN_CONFIG" 2>/dev/null)
    if [[ "$id" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
        return 0
    fi
    return 1
}

# Get all capabilities as a flat list
get_all_capabilities() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        return
    fi
    jq -r '
        [.capabilities.os, .capabilities.arch] +
        (.capabilities.tools // []) +
        (.capabilities.custom // [])
        | .[] | select(. != null and . != "")
    ' "$TOWN_CONFIG" 2>/dev/null
}

# Check if gastown has a specific capability
has_capability() {
    local cap="$1"
    get_all_capabilities | grep -qx "$cap"
}

# Legacy: resolve town ID for backwards compatibility
resolve_legacy_town_id() {
    # 1. Legacy .lirt/town-id file
    if [[ -f "$PROJECT_ROOT/.lirt/town-id" ]]; then
        cat "$PROJECT_ROOT/.lirt/town-id"
        return 0
    fi

    # 2. mayor/town.json name field
    if [[ -f "$PROJECT_ROOT/mayor/town.json" ]]; then
        local name
        name=$(jq -r '.name // empty' "$PROJECT_ROOT/mayor/town.json" 2>/dev/null)
        if [[ -n "$name" ]]; then
            echo "$name"
            return 0
        fi
    fi

    # 3. Git remote basename
    local remote_url
    remote_url=$(git -C "$PROJECT_ROOT" remote get-url origin 2>/dev/null || true)
    if [[ -n "$remote_url" ]]; then
        local basename
        basename=$(echo "$remote_url" | xargs basename 2>/dev/null | sed 's/\.git$//' | sed 's/^gastown-//')
        if [[ -n "$basename" ]]; then
            echo "$basename"
            return 0
        fi
    fi

    return 1
}

# Initialize town configuration
cmd_init() {
    local force=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            --migrate) cmd_migrate; return $? ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done

    if [[ -f "$TOWN_CONFIG" ]]; then
        if is_v2_config; then
            if [[ "$force" != "true" ]]; then
                echo "Town already initialized (v2). Use --force to reinitialize."
                echo ""
                cmd_status
                return 0
            fi
        else
            echo "Detected v1 config. Migrating to v2 format..."
            cmd_migrate
            return $?
        fi
    fi

    echo "Initializing gastown (v2 format)..."
    echo ""

    mkdir -p "$AMBASSADOR_DIR"

    # Generate UUID
    local town_id
    town_id=$(generate_uuid)
    echo "Generated UUID: $town_id"

    # Get hostname and overseer
    local hostname overseer alias
    hostname=$(get_hostname)
    overseer=$(get_overseer)
    alias="${hostname}.${overseer}"
    echo "Hostname: $hostname"
    echo "Overseer: $overseer"
    echo "Alias: $alias"

    # Detect capabilities
    local os arch
    os=$(detect_os)
    arch=$(detect_arch)
    echo "Detected OS: $os"
    echo "Detected Arch: $arch"

    # Detect common tools
    local tools=()
    for tool in go node python3 rust cargo docker kubectl; do
        if command -v "$tool" &> /dev/null; then
            tools+=("\"$tool\"")
        fi
    done
    local tools_json
    tools_json=$(IFS=,; echo "[${tools[*]:-}]")
    echo "Detected Tools: ${tools[*]:-none}"

    # Create config with v2 schema
    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$TOWN_CONFIG" << EOF
{
  "id": "$town_id",
  "alias": "$alias",
  "overseer": "$overseer",
  "hostname": "$hostname",
  "capabilities": {
    "os": "$os",
    "arch": "$arch",
    "tools": $tools_json,
    "custom": []
  },
  "policies": {
    "domains": {
      "allowed": [],
      "restricted": [],
      "requires_approval": []
    },
    "ip_isolation": {
      "client_projects": [],
      "exclusive": false
    },
    "routing": {
      "on_policy_reject": "route-to-capable",
      "on_approval_timeout": "hold",
      "fallback_gastowns": []
    }
  },
  "sync_branch": "$SYNC_BRANCH",
  "created_at": "$now",
  "initialized": "$now"
}
EOF

    echo ""
    echo "Created: $TOWN_CONFIG"

    # Set up sync branch
    echo ""
    cmd_sync_setup

    echo ""
    echo "Gastown initialized successfully"
    echo ""
    echo "Next steps:"
    echo "  - Add custom capabilities: lirt-ambassador caps add <cap>"
    echo "  - Configure policies: lirt-ambassador policy set-domain allowed <domain>"
    echo "  - Check status: lirt-ambassador status"
}

# Migrate from v1 to v2 config
cmd_migrate() {
    echo "Migrating to v2 config format..."

    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "No existing config found. Running init instead."
        cmd_init
        return $?
    fi

    if is_v2_config; then
        echo "Config is already v2 format."
        return 0
    fi

    # Read existing v1 values
    local old_id old_os old_arch old_tools old_custom old_sync_branch old_initialized
    old_id=$(jq -r '.id // ""' "$TOWN_CONFIG")
    old_os=$(jq -r '.capabilities.os // ""' "$TOWN_CONFIG")
    old_arch=$(jq -r '.capabilities.arch // ""' "$TOWN_CONFIG")
    old_tools=$(jq -c '.capabilities.tools // []' "$TOWN_CONFIG")
    old_custom=$(jq -c '.capabilities.custom // []' "$TOWN_CONFIG")
    old_sync_branch=$(jq -r '.sync_branch // "beads-sync"' "$TOWN_CONFIG")
    old_initialized=$(jq -r '.initialized // ""' "$TOWN_CONFIG")

    echo "  Old ID: $old_id"

    # Generate new UUID
    local new_id
    new_id=$(generate_uuid)
    echo "  New UUID: $new_id"

    # Detect hostname and overseer
    local hostname overseer alias
    hostname=$(get_hostname)
    overseer=$(get_overseer)

    # Use old_id as alias if it looks like a human-readable name, otherwise generate
    if [[ -n "$old_id" && ! "$old_id" =~ ^[0-9a-f-]{36}$ ]]; then
        alias="$old_id"
        echo "  Preserving old ID as alias: $alias"
    else
        alias="${hostname}.${overseer}"
        echo "  Generated alias: $alias"
    fi

    local now
    now=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Create v2 config
    cat > "$TOWN_CONFIG" << EOF
{
  "id": "$new_id",
  "alias": "$alias",
  "overseer": "$overseer",
  "hostname": "$hostname",
  "capabilities": {
    "os": "$old_os",
    "arch": "$old_arch",
    "tools": $old_tools,
    "custom": $old_custom
  },
  "policies": {
    "domains": {
      "allowed": [],
      "restricted": [],
      "requires_approval": []
    },
    "ip_isolation": {
      "client_projects": [],
      "exclusive": false
    },
    "routing": {
      "on_policy_reject": "route-to-capable",
      "on_approval_timeout": "hold",
      "fallback_gastowns": []
    }
  },
  "sync_branch": "$old_sync_branch",
  "created_at": "${old_initialized:-$now}",
  "initialized": "$now",
  "migrated_from_v1": "$old_id"
}
EOF

    echo ""
    echo "Migration complete. New config:"
    cmd_whoami
}

# Get town UUID
cmd_id() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized. Run: lirt-ambassador init" >&2
        exit 1
    fi
    jq -r '.id' "$TOWN_CONFIG"
}

# Get town alias
cmd_alias() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized. Run: lirt-ambassador init" >&2
        exit 1
    fi
    jq -r '.alias // .id' "$TOWN_CONFIG"
}

# Show full identity
cmd_whoami() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized. Run: lirt-ambassador init" >&2
        exit 1
    fi

    echo "Town Identity"
    echo "============="
    echo ""
    echo "UUID:     $(jq -r '.id' "$TOWN_CONFIG")"
    echo "Alias:    $(jq -r '.alias // "not set"' "$TOWN_CONFIG")"
    echo "Overseer: $(jq -r '.overseer // "not set"' "$TOWN_CONFIG")"
    echo "Hostname: $(jq -r '.hostname // "not set"' "$TOWN_CONFIG")"
    echo "Created:  $(jq -r '.created_at // "unknown"' "$TOWN_CONFIG")"
}

# Manage capabilities
cmd_caps() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            if [[ ! -f "$TOWN_CONFIG" ]]; then
                echo "Town not initialized. Run: lirt-ambassador init" >&2
                exit 1
            fi
            echo "Capabilities for $(jq -r '.alias // .id' "$TOWN_CONFIG"):"
            echo ""
            echo "OS:     $(jq -r '.capabilities.os // "not set"' "$TOWN_CONFIG")"
            echo "Arch:   $(jq -r '.capabilities.arch // "not set"' "$TOWN_CONFIG")"
            echo "Tools:  $(jq -r '.capabilities.tools | join(", ")' "$TOWN_CONFIG")"
            echo "Custom: $(jq -r '.capabilities.custom | join(", ")' "$TOWN_CONFIG")"
            ;;
        add)
            if [[ -z "${1:-}" ]]; then
                echo "Usage: lirt-ambassador caps add <capability>" >&2
                exit 1
            fi
            if [[ ! -f "$TOWN_CONFIG" ]]; then
                echo "Town not initialized. Run: lirt-ambassador init" >&2
                exit 1
            fi
            local cap="$1"
            local tmp
            tmp=$(jq --arg cap "$cap" '.capabilities.custom += [$cap] | .capabilities.custom |= unique' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Added capability: $cap"
            ;;
        remove)
            if [[ -z "${1:-}" ]]; then
                echo "Usage: lirt-ambassador caps remove <capability>" >&2
                exit 1
            fi
            if [[ ! -f "$TOWN_CONFIG" ]]; then
                echo "Town not initialized. Run: lirt-ambassador init" >&2
                exit 1
            fi
            local cap="$1"
            local tmp
            tmp=$(jq --arg cap "$cap" '.capabilities.custom -= [$cap]' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Removed capability: $cap"
            ;;
        *)
            echo "Usage: lirt-ambassador caps [list|add|remove] [capability]" >&2
            exit 1
            ;;
    esac
}

# Manage policies
cmd_policy() {
    local subcmd="${1:-show}"
    shift || true

    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized. Run: lirt-ambassador init" >&2
        exit 1
    fi

    case "$subcmd" in
        show)
            echo "Policies for $(jq -r '.alias // .id' "$TOWN_CONFIG"):"
            echo ""
            echo "Domains:"
            echo "  Allowed:           $(jq -r '.policies.domains.allowed | join(", ") | if . == "" then "(none)" else . end' "$TOWN_CONFIG")"
            echo "  Restricted:        $(jq -r '.policies.domains.restricted | join(", ") | if . == "" then "(none)" else . end' "$TOWN_CONFIG")"
            echo "  Requires Approval: $(jq -r '.policies.domains.requires_approval | join(", ") | if . == "" then "(none)" else . end' "$TOWN_CONFIG")"
            echo ""
            echo "IP Isolation:"
            echo "  Client Projects:   $(jq -r '.policies.ip_isolation.client_projects | join(", ") | if . == "" then "(none)" else . end' "$TOWN_CONFIG")"
            echo "  Exclusive:         $(jq -r '.policies.ip_isolation.exclusive' "$TOWN_CONFIG")"
            echo ""
            echo "Routing:"
            echo "  On Policy Reject:  $(jq -r '.policies.routing.on_policy_reject' "$TOWN_CONFIG")"
            echo "  On Approval Timeout: $(jq -r '.policies.routing.on_approval_timeout' "$TOWN_CONFIG")"
            ;;
        set-domain)
            local category="${1:-}"
            local domain="${2:-}"
            if [[ -z "$category" || -z "$domain" ]]; then
                echo "Usage: lirt-ambassador policy set-domain <allowed|restricted|requires_approval> <domain>" >&2
                exit 1
            fi
            case "$category" in
                allowed|restricted|requires_approval)
                    local tmp
                    tmp=$(jq --arg cat "$category" --arg dom "$domain" \
                        '.policies.domains[$cat] += [$dom] | .policies.domains[$cat] |= unique' "$TOWN_CONFIG")
                    echo "$tmp" > "$TOWN_CONFIG"
                    echo "Added domain '$domain' to $category"
                    ;;
                *)
                    echo "Category must be: allowed, restricted, or requires_approval" >&2
                    exit 1
                    ;;
            esac
            ;;
        remove-domain)
            local category="${1:-}"
            local domain="${2:-}"
            if [[ -z "$category" || -z "$domain" ]]; then
                echo "Usage: lirt-ambassador policy remove-domain <allowed|restricted|requires_approval> <domain>" >&2
                exit 1
            fi
            local tmp
            tmp=$(jq --arg cat "$category" --arg dom "$domain" \
                '.policies.domains[$cat] -= [$dom]' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Removed domain '$domain' from $category"
            ;;
        set-ip-client)
            local client="${1:-}"
            local exclusive="${2:-false}"
            if [[ -z "$client" ]]; then
                echo "Usage: lirt-ambassador policy set-ip-client <client> [--exclusive]" >&2
                exit 1
            fi
            if [[ "$exclusive" == "--exclusive" ]]; then
                exclusive="true"
            fi
            local tmp
            tmp=$(jq --arg client "$client" --argjson excl "$exclusive" \
                '.policies.ip_isolation.client_projects += [$client] |
                 .policies.ip_isolation.client_projects |= unique |
                 .policies.ip_isolation.exclusive = $excl' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Added IP client: $client (exclusive: $exclusive)"
            ;;
        remove-ip-client)
            local client="${1:-}"
            if [[ -z "$client" ]]; then
                echo "Usage: lirt-ambassador policy remove-ip-client <client>" >&2
                exit 1
            fi
            local tmp
            tmp=$(jq --arg client "$client" \
                '.policies.ip_isolation.client_projects -= [$client]' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Removed IP client: $client"
            ;;
        clear-ip)
            local tmp
            tmp=$(jq '.policies.ip_isolation.client_projects = [] | .policies.ip_isolation.exclusive = false' "$TOWN_CONFIG")
            echo "$tmp" > "$TOWN_CONFIG"
            echo "Cleared IP isolation settings"
            ;;
        *)
            cat << 'EOF'
Usage: lirt-ambassador policy <subcommand>

Subcommands:
  show                                          Show current policies
  set-domain <category> <domain>                Add domain to category
  remove-domain <category> <domain>             Remove domain from category
  set-ip-client <client> [--exclusive]          Add IP client project
  remove-ip-client <client>                     Remove IP client project
  clear-ip                                      Clear all IP isolation settings

Categories for domains: allowed, restricted, requires_approval

Examples:
  lirt-ambassador policy show
  lirt-ambassador policy set-domain allowed identity-management
  lirt-ambassador policy set-domain restricted competitor-code
  lirt-ambassador policy set-ip-client acme-corp --exclusive
EOF
            exit 1
            ;;
    esac
}

# Show gastown status
cmd_status() {
    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized."
        echo "Run: lirt-ambassador init"
        exit 1
    fi

    local is_v2=""
    if is_v2_config; then
        is_v2=" (v2)"
    else
        is_v2=" (v1 - run 'migrate' to upgrade)"
    fi

    echo "Gastown Status$is_v2"
    echo "=============="
    echo ""

    if is_v2_config; then
        echo "UUID:        $(jq -r '.id' "$TOWN_CONFIG")"
        echo "Alias:       $(jq -r '.alias // "not set"' "$TOWN_CONFIG")"
        echo "Overseer:    $(jq -r '.overseer // "not set"' "$TOWN_CONFIG")"
    else
        echo "ID:          $(jq -r '.id' "$TOWN_CONFIG")"
    fi

    echo "Initialized: $(jq -r '.initialized // "unknown"' "$TOWN_CONFIG")"
    echo "Config:      $TOWN_CONFIG"
    echo ""
    echo "Capabilities:"
    echo "  OS:     $(jq -r '.capabilities.os // "not set"' "$TOWN_CONFIG")"
    echo "  Arch:   $(jq -r '.capabilities.arch // "not set"' "$TOWN_CONFIG")"
    echo "  Tools:  $(jq -r '.capabilities.tools | join(", ")' "$TOWN_CONFIG")"
    echo "  Custom: $(jq -r '.capabilities.custom | join(", ")' "$TOWN_CONFIG")"

    # Show policy summary if v2
    if is_v2_config; then
        echo ""
        echo "Policies:"
        local allowed_count restricted_count ip_count
        allowed_count=$(jq -r '.policies.domains.allowed | length' "$TOWN_CONFIG")
        restricted_count=$(jq -r '.policies.domains.restricted | length' "$TOWN_CONFIG")
        ip_count=$(jq -r '.policies.ip_isolation.client_projects | length' "$TOWN_CONFIG")
        echo "  Allowed Domains:    $allowed_count configured"
        echo "  Restricted Domains: $restricted_count configured"
        echo "  IP Client Projects: $ip_count configured"
    fi

    # Check sync branch status
    echo ""
    echo "Project:     $PROJECT_ROOT"
    local sync_branch
    sync_branch=$(jq -r '.sync_branch // "beads-sync"' "$TOWN_CONFIG")
    echo "Sync Branch: $sync_branch"

    cd "$PROJECT_ROOT"
    if git rev-parse --verify "$sync_branch" &>/dev/null; then
        echo "  Local:   exists"
    else
        echo "  Local:   not found"
    fi

    if git ls-remote --heads origin "$sync_branch" 2>/dev/null | grep -q "$sync_branch"; then
        echo "  Remote:  exists on origin"
    else
        echo "  Remote:  not found on origin"
    fi
}

# Set up beads sync branch
cmd_sync_setup() {
    echo "Setting up sync branch: $SYNC_BRANCH"
    echo "  Project: $PROJECT_ROOT"

    cd "$PROJECT_ROOT"

    if git rev-parse --verify "$SYNC_BRANCH" &>/dev/null; then
        echo "  Local branch exists"
    else
        if git ls-remote --heads origin "$SYNC_BRANCH" 2>/dev/null | grep -q "$SYNC_BRANCH"; then
            echo "  Fetching from remote..."
            git fetch origin "$SYNC_BRANCH:$SYNC_BRANCH"
        else
            echo "  Creating new branch..."
            local current_branch
            current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")

            git checkout --orphan "$SYNC_BRANCH"
            git reset --hard
            echo "# Beads Sync Branch" > README.md
            echo "" >> README.md
            echo "This branch is used for beads synchronization across gastowns." >> README.md
            echo "Do not merge this branch into main." >> README.md
            git add README.md
            git commit -m "Initialize beads sync branch"
            git checkout "$current_branch" 2>/dev/null || git checkout main 2>/dev/null || true
            echo "  Created local branch"
        fi
    fi

    if ! git ls-remote --heads origin "$SYNC_BRANCH" 2>/dev/null | grep -q "$SYNC_BRANCH"; then
        echo "  Pushing to remote..."
        git push -u origin "$SYNC_BRANCH"
    fi

    if command -v bd &> /dev/null; then
        if bd config get sync_branch &>/dev/null 2>&1; then
            bd config set sync_branch "$SYNC_BRANCH" 2>/dev/null || true
            echo "  Configured beads sync branch"
        fi
    fi

    echo "  Sync branch ready"
}

# Assess if this gastown can handle an issue
cmd_assess() {
    local issue_id="${1:-}"
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v) verbose=true; shift ;;
            -*) echo "Unknown option: $1" >&2; exit 1 ;;
            *) issue_id="$1"; shift ;;
        esac
    done

    if [[ -z "$issue_id" ]]; then
        echo "Usage: lirt-ambassador assess <issue-id> [--verbose]" >&2
        exit 1
    fi

    if [[ ! -f "$TOWN_CONFIG" ]]; then
        echo "Town not initialized. Run: lirt-ambassador init" >&2
        exit 1
    fi

    # Get issue details
    local issue_json
    issue_json=$(bd show "$issue_id" --json 2>/dev/null | jq '.[0]') || {
        echo "Error: Could not find issue $issue_id" >&2
        exit 1
    }

    if [[ -z "$issue_json" || "$issue_json" == "null" ]]; then
        echo "Error: Could not find issue $issue_id" >&2
        exit 1
    fi

    local title
    title=$(echo "$issue_json" | jq -r '.title // "untitled"')
    echo "Issue: $issue_id"
    echo "Title: $title"
    echo ""

    local can_handle=true
    local decision="PROCEED"
    local reason=""

    # === PHASE 1: POLICY CLASSIFICATION CHECK ===
    local has_domain has_ip
    if echo "$issue_json" | jq -e '.labels[]? | select(startswith("domain:"))' >/dev/null 2>&1; then
        has_domain="true"
    else
        has_domain="false"
    fi
    if echo "$issue_json" | jq -e '.labels[]? | select(startswith("ip:"))' >/dev/null 2>&1; then
        has_ip="true"
    else
        has_ip="false"
    fi

    if [[ "$has_domain" != "true" ]]; then
        echo "QUARANTINED: Missing domain classification"
        echo "  Run: lirt-ambassador classify $issue_id"
        exit 2
    fi

    [[ "$verbose" == "true" ]] && echo "Policy classification: present"

    # === PHASE 2: CAPABILITY CHECK (requires:) ===
    local required_caps
    required_caps=$(echo "$issue_json" | jq -r '.labels[]? | select(startswith("requires:")) | sub("requires:"; "")' 2>/dev/null | sort -u)

    if [[ -n "$required_caps" ]]; then
        echo "Required capabilities:"
        local missing_required=()
        while IFS= read -r req; do
            [[ -z "$req" ]] && continue
            if has_capability "$req"; then
                echo "  + $req"
            else
                echo "  - $req (MISSING)"
                can_handle=false
                missing_required+=("$req")
            fi
        done <<< "$required_caps"

        if [[ "$can_handle" == "false" ]]; then
            decision="ROUTE"
            reason="Missing required capabilities: ${missing_required[*]}"
        fi
    else
        [[ "$verbose" == "true" ]] && echo "Required capabilities: none"
    fi

    # === PHASE 3: CAPABILITY CHECK (excludes:) ===
    local excluded_caps
    excluded_caps=$(echo "$issue_json" | jq -r '.labels[]? | select(startswith("excludes:")) | sub("excludes:"; "")' 2>/dev/null | sort -u)

    if [[ -n "$excluded_caps" ]]; then
        echo "Excluded capabilities:"
        local present_excluded=()
        while IFS= read -r excl; do
            [[ -z "$excl" ]] && continue
            if has_capability "$excl"; then
                echo "  ! $excl (PRESENT - violates exclusion)"
                can_handle=false
                present_excluded+=("$excl")
            else
                echo "  - $excl (absent, ok)"
            fi
        done <<< "$excluded_caps"

        if [[ ${#present_excluded[@]} -gt 0 ]]; then
            decision="ROUTE"
            reason="Has excluded capabilities: ${present_excluded[*]}"
        fi
    else
        [[ "$verbose" == "true" ]] && echo "Excluded capabilities: none"
    fi

    # === PHASE 4: DOMAIN POLICY CHECK ===
    if [[ "$can_handle" == "true" ]] && is_v2_config; then
        local task_domain
        task_domain=$(echo "$issue_json" | jq -r '.labels[]? | select(startswith("domain:")) | sub("domain:"; "")' 2>/dev/null | head -1)

        if [[ -n "$task_domain" ]]; then
            local in_allowed in_restricted in_approval
            in_allowed=$(jq --arg d "$task_domain" '.policies.domains.allowed | index($d) != null' "$TOWN_CONFIG")
            in_restricted=$(jq --arg d "$task_domain" '.policies.domains.restricted | index($d) != null' "$TOWN_CONFIG")
            in_approval=$(jq --arg d "$task_domain" '.policies.domains.requires_approval | index($d) != null' "$TOWN_CONFIG")

            local allowed_empty
            allowed_empty=$(jq '.policies.domains.allowed | length == 0' "$TOWN_CONFIG")

            echo ""
            echo "Domain policy:"
            echo "  Task domain: $task_domain"

            if [[ "$in_restricted" == "true" ]]; then
                echo "  Status: RESTRICTED"
                can_handle=false
                decision="REJECT"
                reason="Domain '$task_domain' is restricted on this gastown"
            elif [[ "$in_approval" == "true" ]]; then
                # Check if already approved
                local is_approved
                if echo "$issue_json" | jq -e '.labels[]? | select(. == "approval:granted")' >/dev/null 2>&1; then
                    is_approved="true"
                else
                    is_approved="false"
                fi
                if [[ "$is_approved" == "true" ]]; then
                    echo "  Status: APPROVED"
                else
                    echo "  Status: REQUIRES APPROVAL"
                    can_handle=false
                    decision="HOLD"
                    reason="Domain '$task_domain' requires overseer approval"
                fi
            elif [[ "$in_allowed" == "true" || "$allowed_empty" == "true" ]]; then
                echo "  Status: allowed"
            else
                echo "  Status: not in allowed list (implicit deny)"
                can_handle=false
                decision="ROUTE"
                reason="Domain '$task_domain' not in allowed list"
            fi
        fi
    fi

    # === PHASE 5: IP ISOLATION CHECK ===
    if [[ "$can_handle" == "true" ]] && is_v2_config; then
        local task_ip
        task_ip=$(echo "$issue_json" | jq -r '.labels[]? | select(startswith("ip:")) | sub("ip:"; "")' 2>/dev/null | head -1)

        local exclusive
        exclusive=$(jq -r '.policies.ip_isolation.exclusive' "$TOWN_CONFIG")

        if [[ -n "$task_ip" && "$task_ip" != "public" && "$exclusive" == "true" ]]; then
            local in_clients
            in_clients=$(jq --arg ip "$task_ip" '.policies.ip_isolation.client_projects | index($ip) != null' "$TOWN_CONFIG")

            echo ""
            echo "IP isolation:"
            echo "  Task IP scope: $task_ip"
            echo "  Exclusive mode: $exclusive"

            if [[ "$in_clients" == "true" ]]; then
                echo "  Status: allowed (client match)"
            else
                echo "  Status: REJECTED (IP isolation)"
                can_handle=false
                decision="ROUTE"
                reason="IP '$task_ip' not in client list (exclusive mode)"
            fi
        fi
    fi

    # === FINAL DECISION ===
    echo ""
    echo "================================"
    case "$decision" in
        PROCEED)
            echo "Result: CAN HANDLE"
            exit 0
            ;;
        ROUTE)
            echo "Result: CANNOT HANDLE - ROUTE"
            echo "Reason: $reason"
            echo ""
            echo "Route with: lirt-ambassador route $issue_id"
            exit 1
            ;;
        HOLD)
            echo "Result: HOLD FOR APPROVAL"
            echo "Reason: $reason"
            echo ""
            echo "Approve with: lirt-ambassador approve $issue_id"
            echo "Deny with: lirt-ambassador deny $issue_id"
            exit 3
            ;;
        REJECT)
            echo "Result: REJECTED"
            echo "Reason: $reason"
            exit 4
            ;;
    esac
}

# Route issue to appropriate gastown
cmd_route() {
    local issue_id=""
    local target_town=""
    local target_cap=""
    local policy_reason=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --to) target_town="$2"; shift 2 ;;
            --capability|--cap) target_cap="$2"; shift 2 ;;
            --reason) policy_reason="$2"; shift 2 ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$issue_id" ]]; then
                    issue_id="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$issue_id" ]]; then
        echo "Usage: lirt-ambassador route <issue-id> [--to <town-id>] [--capability <cap>] [--reason <text>]" >&2
        exit 1
    fi

    echo "Routing issue: $issue_id"

    # Add routing audit trail
    local my_id
    my_id=$(cmd_id)
    local route_label="routed-from:$my_id"

    if [[ -n "$target_town" ]]; then
        echo "  Target: $target_town"
        bd update "$issue_id" --assignee "$target_town" --status open --add-label "$route_label"
        bd sync
        echo "  Routed to $target_town"
    elif [[ -n "$target_cap" ]]; then
        echo "  Required capability: $target_cap"
        bd update "$issue_id" --add-label "requires:$target_cap" --add-label "$route_label" --assignee "" --status open
        bd sync
        echo "  Labeled with requires:$target_cap and made available"
    else
        bd update "$issue_id" --add-label "$route_label" --assignee "" --status open
        bd sync
        echo "  Released to pool (any gastown can claim)"
    fi

    if [[ -n "$policy_reason" ]]; then
        bd update "$issue_id" --notes "Routed: $policy_reason"
    fi
}

# Create a policy-qualified bead
cmd_create() {
    local title="" type="task" domain="" ip="public" priority="2"
    local description="" auto_classify=false
    local extra_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title) title="$2"; shift 2 ;;
            --type) type="$2"; shift 2 ;;
            --domain) domain="$2"; shift 2 ;;
            --ip) ip="$2"; shift 2 ;;
            --priority) priority="$2"; shift 2 ;;
            --description) description="$2"; shift 2 ;;
            --auto-classify) auto_classify=true; shift ;;
            --*)
                extra_args+=("$1" "$2")
                shift 2
                ;;
            *)
                if [[ -z "$title" ]]; then
                    title="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$title" ]]; then
        echo "Usage: lirt-ambassador create --title \"...\" [options]" >&2
        echo ""
        echo "Options:"
        echo "  --title <text>       Bead title (required)"
        echo "  --type <type>        Bead type: task, bug, feature, chronicle, decision (default: task)"
        echo "  --domain <domain>    Domain classification (required unless --auto-classify)"
        echo "  --ip <scope>         IP scope: public or client name (default: public)"
        echo "  --priority <0-4>     Priority (default: 2)"
        echo "  --description <text> Description"
        echo "  --auto-classify      Auto-detect domain from title/description"
        exit 1
    fi

    # Auto-classify domain if requested
    if [[ "$auto_classify" == "true" && -z "$domain" ]]; then
        domain=$(auto_classify_domain "$title" "$description")
        echo "Auto-classified domain: $domain"
    fi

    # Require domain classification
    if [[ -z "$domain" ]]; then
        echo "Domain classification required." >&2
        echo ""
        echo "Known domains: general-programming, identity-management, devops, testing,"
        echo "               documentation, code-quality, architecture, security"
        echo ""
        echo "Specify with --domain <domain> or use --auto-classify"
        exit 1
    fi

    # Build labels
    local labels="domain:$domain,ip:$ip"

    # Create the bead
    echo "Creating bead..."
    echo "  Title: $title"
    echo "  Type: $type"
    echo "  Domain: $domain"
    echo "  IP: $ip"
    echo "  Priority: $priority"

    local bd_args=(
        --title "$title"
        --type "$type"
        --priority "$priority"
        --labels "$labels"
    )

    if [[ -n "$description" ]]; then
        bd_args+=(--description "$description")
    fi

    bd create "${bd_args[@]}" "${extra_args[@]}"
}

# Create a chronicle bead (diary-worthy moment)
cmd_chronicle() {
    local title="" category="insight" domain="" description=""
    local extra_labels=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title) title="$2"; shift 2 ;;
            --category) category="$2"; shift 2 ;;
            --domain) domain="$2"; shift 2 ;;
            --description) description="$2"; shift 2 ;;
            --label) extra_labels+=("$2"); shift 2 ;;
            --auto-classify)
                if [[ -n "$title" ]]; then
                    domain=$(auto_classify_domain "$title" "$description")
                fi
                shift
                ;;
            *)
                if [[ -z "$title" ]]; then
                    title="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$title" ]]; then
        echo "Usage: lirt-ambassador chronicle --title \"...\" [options]" >&2
        echo ""
        echo "Options:"
        echo "  --title <text>       Chronicle title (required)"
        echo "  --category <cat>     Category: decision, insight, pattern, correction, lesson (default: insight)"
        echo "  --domain <domain>    Domain classification (or --auto-classify)"
        echo "  --description <text> Full description of the chronicle-worthy moment"
        echo "  --label <label>      Additional labels (can repeat)"
        echo "  --auto-classify      Auto-detect domain from title"
        echo ""
        echo "Categories:"
        echo "  decision    - Architectural or design choice with alternatives"
        echo "  insight     - Realization that changed understanding"
        echo "  pattern     - Recurring theme recognized"
        echo "  correction  - Direction change and why"
        echo "  lesson      - What worked/didn't and why"
        exit 1
    fi

    # Ensure title starts with "Chronicle:" for visibility
    if [[ ! "$title" =~ ^Chronicle: ]]; then
        title="Chronicle: $title"
    fi

    # Auto-classify if domain not specified
    if [[ -z "$domain" ]]; then
        domain=$(auto_classify_domain "$title" "$description")
        echo "Auto-classified domain: $domain"
    fi

    # Build labels
    local labels="chronicle,$category,domain:$domain,ip:public"
    for lbl in "${extra_labels[@]}"; do
        labels="$labels,$lbl"
    done

    echo "Creating chronicle bead..."
    echo "  Title: $title"
    echo "  Category: $category"
    echo "  Domain: $domain"

    local bd_args=(
        --title "$title"
        --type task
        --priority 3
        --labels "$labels"
    )

    if [[ -n "$description" ]]; then
        bd_args+=(--description "$description")
    fi

    bd create "${bd_args[@]}"

    echo ""
    echo "Run 'lirt-chronicler' to process chronicle beads into diary entries."
}

# Auto-classify domain based on keywords
auto_classify_domain() {
    local title="$1"
    local description="${2:-}"
    local text="$title $description"
    text=$(echo "$text" | tr '[:upper:]' '[:lower:]')

    case "$text" in
        *auth*|*login*|*oauth*|*identity*|*credential*|*password*|*session*)
            echo "identity-management" ;;
        *deploy*|*kubernetes*|*docker*|*ci/cd*|*pipeline*|*infra*|*terraform*)
            echo "devops" ;;
        *test*|*spec*|*coverage*|*assert*|*mock*)
            echo "testing" ;;
        *doc*|*readme*|*comment*|*changelog*)
            echo "documentation" ;;
        *refactor*|*cleanup*|*lint*|*format*|*style*)
            echo "code-quality" ;;
        *architect*|*design*|*pattern*|*structure*)
            echo "architecture" ;;
        *security*|*vuln*|*cve*|*encrypt*|*hash*)
            echo "security" ;;
        *)
            echo "general-programming" ;;
    esac
}

# Classify existing bead
cmd_classify() {
    local issue_id="${1:-}"
    local domain="" ip=""

    shift || true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --domain) domain="$2"; shift 2 ;;
            --ip) ip="$2"; shift 2 ;;
            --auto)
                # Get issue title for auto-classification
                local title
                title=$(bd show "$issue_id" --json 2>/dev/null | jq -r '.[0].title // ""')
                domain=$(auto_classify_domain "$title" "")
                echo "Auto-classified domain: $domain"
                shift
                ;;
            *) shift ;;
        esac
    done

    if [[ -z "$issue_id" ]]; then
        echo "Usage: lirt-ambassador classify <issue-id> [--domain <domain>] [--ip <scope>] [--auto]" >&2
        exit 1
    fi

    # Interactive if no domain specified
    if [[ -z "$domain" ]]; then
        echo "Domain classification required."
        echo ""
        echo "Known domains:"
        echo "  1. general-programming"
        echo "  2. identity-management"
        echo "  3. devops"
        echo "  4. testing"
        echo "  5. documentation"
        echo "  6. code-quality"
        echo "  7. architecture"
        echo "  8. security"
        echo ""
        read -p "Enter domain (name or number): " domain_input

        case "$domain_input" in
            1) domain="general-programming" ;;
            2) domain="identity-management" ;;
            3) domain="devops" ;;
            4) domain="testing" ;;
            5) domain="documentation" ;;
            6) domain="code-quality" ;;
            7) domain="architecture" ;;
            8) domain="security" ;;
            *) domain="$domain_input" ;;
        esac
    fi

    if [[ -z "$ip" ]]; then
        ip="public"
    fi

    echo "Classifying $issue_id..."
    echo "  Domain: $domain"
    echo "  IP: $ip"

    bd update "$issue_id" --add-label "domain:$domain" --add-label "ip:$ip"
    echo "Classification complete"
}

# List quarantined beads (missing policy classification)
cmd_quarantine() {
    echo "Quarantined beads (missing policy classification):"
    echo ""

    local found=false
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local id
        id=$(echo "$line" | awk '{print $1}')
        [[ -z "$id" ]] && continue

        local has_domain
        has_domain=$(bd show "$id" --json 2>/dev/null | jq -e '.[0].labels[]? | select(startswith("domain:"))' 2>/dev/null && echo "true" || echo "false")

        if [[ "$has_domain" != "true" ]]; then
            echo "$line"
            found=true
        fi
    done < <(bd list --status open 2>/dev/null || true)

    if [[ "$found" == "false" ]]; then
        echo "(none)"
    fi

    echo ""
    echo "Classify with: lirt-ambassador classify <issue-id>"
}

# List policy-qualified beads ready for work
cmd_ready() {
    # Pass through to bd ready, but filter for policy-qualified beads
    bd ready --label "domain:*" "$@" 2>/dev/null || {
        echo "No policy-qualified beads ready for work."
        echo ""
        echo "Check quarantine: lirt-ambassador quarantine"
    }
}

# List beads awaiting approval
cmd_approvals() {
    echo "Beads awaiting approval:"
    echo ""
    bd list --status open --label "approval:pending" 2>/dev/null || echo "(none)"
}

# Approve a held bead
cmd_approve() {
    local issue_id="${1:-}"
    if [[ -z "$issue_id" ]]; then
        echo "Usage: lirt-ambassador approve <issue-id>" >&2
        exit 1
    fi

    echo "Approving: $issue_id"
    bd update "$issue_id" --remove-label "approval:pending" --add-label "approval:granted"
    echo "Approved. Bead can now be claimed."
}

# Deny a held bead
cmd_deny() {
    local issue_id="${1:-}"
    local route=false ban=false
    shift || true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --route) route=true; shift ;;
            --ban) ban=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$issue_id" ]]; then
        echo "Usage: lirt-ambassador deny <issue-id> [--route] [--ban]" >&2
        exit 1
    fi

    echo "Denying: $issue_id"
    bd update "$issue_id" --remove-label "approval:pending" --add-label "approval:denied"

    if [[ "$route" == "true" ]]; then
        echo "Routing to other gastowns..."
        cmd_route "$issue_id" --reason "Approval denied, routing to other capable gastown"
    elif [[ "$ban" == "true" ]]; then
        echo "Banning from this gastown..."
        local my_id
        my_id=$(cmd_id)
        bd update "$issue_id" --add-label "banned-from:$my_id"
    fi

    echo "Denied."
}

# Show help
cmd_help() {
    cat << 'EOF'
lirt-ambassador - Multi-gastown coordination (v2)

Usage: lirt-ambassador <command> [args]

IDENTITY COMMANDS:
  init [--force]         Initialize this gastown (UUID, capabilities, policies)
  migrate                Migrate v1 config to v2 format
  id                     Get town UUID
  alias                  Get town alias (hostname.overseer)
  whoami                 Show full identity

CAPABILITY COMMANDS:
  caps list              Show all capabilities
  caps add <cap>         Add a custom capability
  caps remove <cap>      Remove a custom capability

POLICY COMMANDS:
  policy show                              Show current policies
  policy set-domain <category> <domain>    Add domain to allowed/restricted/requires_approval
  policy remove-domain <category> <domain> Remove domain from category
  policy set-ip-client <client> [--excl]   Add IP client project
  policy remove-ip-client <client>         Remove IP client project
  policy clear-ip                          Clear all IP isolation

BEAD CREATION (ENFORCED):
  create --title "..." [options]   Create a policy-qualified bead
    --domain <domain>              Domain classification (required)
    --ip <scope>                   IP scope (default: public)
    --type <type>                  Bead type (default: task)
    --auto-classify                Auto-detect domain from title

  classify <issue-id> [options]    Add policy classification to existing bead
    --domain <domain>              Domain classification
    --ip <scope>                   IP scope
    --auto                         Auto-classify from title

  chronicle --title "..." [opts]   Create a chronicle bead (diary-worthy moment)
    --category <cat>               decision, insight, pattern, correction, lesson
    --domain <domain>              Domain classification
    --description <text>           Full description
    --auto-classify                Auto-detect domain from title

ASSESSMENT & ROUTING:
  assess <issue-id> [--verbose]    Check if this gastown can handle an issue
  route <issue-id> [options]       Route issue to appropriate gastown
    --to <town-id>                 Route to specific gastown
    --capability <cap>             Route to any gastown with capability
    --reason <text>                Add routing reason

WORK MANAGEMENT:
  status                 Show current gastown status
  ready                  List policy-qualified beads ready for work
  quarantine             List beads without policy classification
  approvals              List beads awaiting overseer approval
  approve <issue-id>     Grant approval for a held bead
  deny <issue-id>        Deny approval (--route or --ban)
  sync-setup             Set up the beads sync branch

EXIT CODES:
  0  Success / CAN HANDLE
  1  Error / CANNOT HANDLE - ROUTE
  2  QUARANTINED (missing classification)
  3  HOLD FOR APPROVAL
  4  REJECTED (policy violation)

Examples:
  lirt-ambassador init
  lirt-ambassador create --title "Fix auth bug" --domain identity-management
  lirt-ambassador classify beads-123 --auto
  lirt-ambassador assess beads-123
  lirt-ambassador policy set-domain allowed general-programming
  lirt-ambassador policy set-ip-client acme-corp --exclusive
EOF
}

# Main
main() {
    check_deps

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init) cmd_init "$@" ;;
        migrate) cmd_migrate "$@" ;;
        id) cmd_id "$@" ;;
        alias) cmd_alias "$@" ;;
        whoami) cmd_whoami "$@" ;;
        caps) cmd_caps "$@" ;;
        policy) cmd_policy "$@" ;;
        status) cmd_status "$@" ;;
        assess) cmd_assess "$@" ;;
        route) cmd_route "$@" ;;
        create) cmd_create "$@" ;;
        chronicle) cmd_chronicle "$@" ;;
        classify) cmd_classify "$@" ;;
        quarantine) cmd_quarantine "$@" ;;
        ready) cmd_ready "$@" ;;
        approvals) cmd_approvals "$@" ;;
        approve) cmd_approve "$@" ;;
        deny) cmd_deny "$@" ;;
        sync-setup) cmd_sync_setup "$@" ;;
        help|--help|-h) cmd_help ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'lirt-ambassador help' for usage" >&2
            exit 1
            ;;
    esac
}

main "$@"
