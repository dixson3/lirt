{"id":"hq-19f","title":"Session-start remote branch detection for private branch rigs","description":"Implement session-start detection to check if remote tracking branch still exists.\n\n**Context**: Private branch protocol risk - agent might work on orphaned local branch if remote was deleted after MR merge.\n\n**Implementation**:\n- Add check at session start for ai_agents and zero rigs\n- Run: git fetch --prune origin\n- Check: git ls-remote --heads origin dixson3/track\n- If remote deleted: Alert agent that local branch is orphaned\n- Recommend sync before continuing work\n\n**Benefits**:\n- Prevents work accumulating on disconnected branch\n- Early warning system for Scenario A (branch removed)\n- Reduces risk of surprise at push time\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Challenge 2\n\n**Acceptance Criteria**:\n- Detection script created\n- Integrated into session startup\n- Clear alert message to agent\n- Recommendation for sync action","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-24T12:45:29.653227-08:00","created_by":"mayor","updated_at":"2026-01-24T12:45:29.653227-08:00"}
{"id":"hq-2sn","title":"Backup strategy for private tracking branches","description":"Implement periodic backup strategy for dixson3/track branches on ai_agents and zero.\n\n**Context**: Local tracking branches contain unpublished work. No remote backup unless explicitly pushed.\n\n**Backup Strategy**:\nOptions to consider:\n1. **Periodic snapshots**: Weekly backup branches to remote\n   - Naming: dixson3/track-backup-YYYYMMDD\n   - Cleanup: Delete backups older than 30 days\n2. **Pre-MR backup**: Automatic backup before creating MR\n   - Naming: dixson3/track-pre-mr-TIMESTAMP\n3. **On-demand**: Manual backup command\n   - Usage: gt backup-branch --rig ai_agents\n\n**Implementation**:\n- Script or formula for backup creation\n- Cleanup mechanism for old backups\n- Clear naming convention\n- Documentation in protocol\n\n**Trade-offs**:\n- Pro: Safety net for local work\n- Pro: Disaster recovery option\n- Con: Remote repository clutter\n- Con: Additional maintenance\n\n**Benefits**:\n- Work preservation\n- Peace of mind\n- Recovery from local failures\n- No work loss risk\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Challenge (deferred)\n\n**Acceptance Criteria**:\n- Backup mechanism chosen\n- Implementation complete\n- Cleanup automation\n- Documentation updated\n- Tested on both rigs","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-24T12:45:59.286525-08:00","created_by":"mayor","updated_at":"2026-01-24T12:45:59.286525-08:00"}
{"id":"hq-5jg","title":"Alternative push triggers for private branches","description":"Design and implement alternative push triggers beyond explicit overseer request.\n\n**Context**: Current protocol only pushes on explicit overseer command. Explore other trigger options.\n\n**Potential Triggers**:\n1. **Commit count**: Push after N commits (e.g., every 10 commits)\n   - Pro: Regular checkpoints\n   - Con: Might push incomplete work\n2. **Time-based**: Push weekly/daily\n   - Pro: Consistent backup cadence\n   - Con: May miss important work\n3. **Keyword-based**: Commit message with [PUBLISH] or [PUSH]\n   - Pro: Explicit but agent-driven\n   - Con: Easy to forget\n4. **Milestone-based**: After completing a bead/issue\n   - Pro: Logical checkpoints\n   - Con: Requires integration\n5. **Size-based**: Push when diff exceeds threshold\n   - Pro: Captures significant work\n   - Con: Arbitrary cutoff\n\n**Design Considerations**:\n- Should triggers be opt-in per rig?\n- How to prevent unwanted pushes?\n- Override mechanism?\n- Notification to overseer?\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Sidequests\n\n**Acceptance Criteria**:\n- Trigger options evaluated\n- Recommendation with pros/cons\n- Prototype implementation (if approved)\n- Configuration mechanism\n- Documentation","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-24T12:46:04.490067-08:00","created_by":"mayor","updated_at":"2026-01-24T12:46:04.490067-08:00"}
{"id":"hq-8an","title":"Post-MR merge sync automation script","description":"Create automation script to detect Scenario A vs B and sync local branch after MR merge.\n\n**Context**: After MR merges, agent needs to sync local tracking branch but scenario detection is manual.\n\n**Implementation**:\nScript that:\n1. Detects scenario (git ls-remote check)\n2. If Scenario A (remote deleted):\n   - Validates no orphaned commits\n   - Resets local branch to parent\n   - Reports clean slate\n3. If Scenario B (remote retained):\n   - Rebases local branch on parent\n   - Detects duplicate commits (if squash merge)\n   - Cleans history if needed\n4. Reports actions taken\n\n**Usage**:\n```bash\ngt post-mr-sync --rig ai_agents\n# or\ngt post-mr-sync --rig zero\n```\n\n**Benefits**:\n- Reduces manual steps\n- Consistent scenario handling\n- Automatic duplicate detection\n- Clear reporting of actions\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Challenge 2\n\n**Acceptance Criteria**:\n- Script created in scripts/\n- Works for both ai_agents and zero\n- Handles both scenarios\n- Clear output of actions taken\n- Integrates with gt command suite","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-24T12:45:45.151319-08:00","created_by":"mayor","updated_at":"2026-01-24T12:45:45.151319-08:00"}
{"id":"hq-8mi","title":"Merge strategy detection and monitoring tool","description":"Create tool to detect and monitor remote merge strategy for private branch rigs.\n\n**Context**: Protocol safety depends on merge strategy (merge commit vs squash). Need to detect changes.\n\n**Implementation**:\nTool that:\n1. Analyzes recent merges on parent branch\n2. Determines strategy (fast-forward, merge commit, squash)\n3. Validates scenario compatibility\n4. Warns if strategy changes\n5. Updates rig configuration with findings\n\n**Detection Logic**:\n- Merge commit: 'Merge branch X into Y' commits present\n- Squash: Single commits, branch names absent\n- Fast-forward: Linear history\n\n**Monitoring**:\n- Run quarterly or on rig config change\n- Alert if strategy shifts to squash (breaks Scenario B)\n- Recommend protocol adjustments\n\n**Benefits**:\n- Early detection of strategy changes\n- Prevents duplicate commit issues\n- Validates scenario safety\n- Documents merge patterns\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Challenge 1, 6\n\n**Acceptance Criteria**:\n- Detection script created\n- Clear strategy identification\n- Scenario compatibility validation\n- Alert mechanism for changes\n- Updates rig config with findings","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-24T12:45:52.521703-08:00","created_by":"mayor","updated_at":"2026-01-24T12:45:52.521703-08:00"}
{"id":"hq-b6y","title":"Boot handoff","description":"Completed triage cycle.\nAction: NOTHING\nObservations: Deacon session alive, agent_state idle, no pending mail, no error signals\nTime: Mon Jan 26 15:51:32 PST 2026","status":"open","priority":2,"issue_type":"message","created_at":"2026-01-26T15:51:33.381803-08:00","created_by":"overseer","updated_at":"2026-01-26T15:51:33.381803-08:00"}
{"id":"hq-crew-role","title":"Crew Role","description":"Role definition for Crew agents. Persistent user-managed workspaces.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:33.32531Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:33.32531Z"}
{"id":"hq-deacon","title":"Deacon (daemon beacon) - receives mechanical heartbeats, runs town plugins and monitoring.","description":"Deacon (daemon beacon) - receives mechanical heartbeats, runs town plugins and monitoring.\n\nrole_type: deacon\nrig: null\nagent_state: idle\nhook_bead: null\nrole_bead: hq-deacon-role\ncleanup_status: null\nactive_mr: null\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-21T08:19:33.656324Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:33.726467Z"}
{"id":"hq-deacon-role","title":"Deacon Role","description":"Role definition for Deacon agents. Daemon beacon for heartbeats and monitoring.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:32.494663Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:32.494663Z"}
{"id":"hq-dog-role","title":"Dog Role","description":"Role definition for Dog agents. Town-level workers for cross-rig tasks.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:32.661667Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:32.661667Z"}
{"id":"hq-h38","title":"Pre-reset orphaned commit validation for private branch sync","description":"Add validation check before resetting local tracking branch in Scenario A.\n\n**Context**: Private branch protocol risk - unpushed local commits could be lost when resetting branch after MR merge.\n\n**Implementation**:\n- Before git reset --hard in Scenario A\n- Check: git log origin/main..dixson3/track --oneline\n- If unpushed commits found: HALT and alert overseer\n- Options: abort reset, create backup branch, cherry-pick after reset\n- Require explicit confirmation before proceeding\n\n**Scenario**:\n1. Work on dixson3/track (commits A, B, C)\n2. Push, create MR (from A, B, C)\n3. Continue working (add commits D, E locally)\n4. MR merges, remote deletes branch\n5. Without validation: D, E lost on reset\n6. With validation: D, E detected, overseer notified\n\n**Benefits**:\n- Prevents work loss\n- Forces conscious decision about unpushed commits\n- Backup strategies can be applied\n\n**Related**: mayor/docs/PRIVATE-BRANCH-PROTOCOL-REVIEW.md Challenge 3\n\n**Acceptance Criteria**:\n- Pre-reset validation function\n- Clear alert with commit list\n- Options presented to overseer\n- Abort capability if unsure","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-24T12:45:37.662843-08:00","created_by":"mayor","updated_at":"2026-01-24T12:45:37.662843-08:00"}
{"id":"hq-mayor","title":"Mayor - global coordinator, handles cross-rig communication and escalations.","description":"Mayor - global coordinator, handles cross-rig communication and escalations.\n\nrole_type: mayor\nrig: null\nagent_state: idle\nhook_bead: null\nrole_bead: hq-mayor-role\ncleanup_status: null\nactive_mr: null\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","created_at":"2026-01-21T08:19:33.492439Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:33.563096Z"}
{"id":"hq-mayor-role","title":"Mayor Role","description":"Role definition for Mayor agents. Global coordinator for cross-rig work.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:32.33183Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:32.33183Z"}
{"id":"hq-polecat-role","title":"Polecat Role","description":"Role definition for Polecat agents. Ephemeral workers for batch work dispatch.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:33.158728Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:33.158728Z"}
{"id":"hq-refinery-role","title":"Refinery Role","description":"Role definition for Refinery agents. Merge queue processor with verification gates.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:32.994903Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:32.994903Z"}
{"id":"hq-wisp-0wm","title":"Aggregate daily patrol digests","description":"**DAILY DIGEST** - Aggregate yesterday's patrol cycle digests.\n\nPatrol cycles (Deacon, Witness, Refinery) create ephemeral per-cycle digests\nto avoid JSONL pollution. This step aggregates them into a single permanent\n\"Patrol Report YYYY-MM-DD\" bead for audit purposes.\n\n**Step 1: Check if digest is needed**\n```bash\n# Preview yesterday's patrol digests (dry run)\ngt patrol digest --yesterday --dry-run\n```\n\nIf output shows \"No patrol digests found\", skip to Step 3.\n\n**Step 2: Create the digest**\n```bash\ngt patrol digest --yesterday\n```\n\nThis:\n- Queries all ephemeral patrol digests from yesterday\n- Creates a single \"Patrol Report YYYY-MM-DD\" bead with aggregated data\n- Deletes the source digests\n\n**Step 3: Verify**\nDaily patrol digests preserve audit trail without per-cycle pollution.\n\n**Timing**: Run once per morning patrol cycle. The --yesterday flag ensures\nwe don't try to digest today's incomplete data.\n\n**Exit criteria:** Yesterday's patrol digests aggregated (or none to aggregate).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.458913-08:00","updated_at":"2026-01-25T10:34:27.458913-08:00","ephemeral":true}
{"id":"hq-wisp-151","title":"Aggregate daily costs [DISABLED]","description":"**⚠️ DISABLED** - Skip this step entirely.\n\nCost tracking is temporarily disabled because Claude Code does not expose\nsession costs in a way that can be captured programmatically.\n\n**Why disabled:**\n- The `gt costs` command uses tmux capture-pane to find costs\n- Claude Code displays costs in the TUI status bar, not in scrollback\n- All sessions show $0.00 because capture-pane can't see TUI chrome\n- The infrastructure is sound but has no data source\n\n**What we need from Claude Code:**\n- Stop hook env var (e.g., `$CLAUDE_SESSION_COST`)\n- Or queryable file/API endpoint\n\n**Re-enable when:** Claude Code exposes cost data via API or environment.\n\nSee: GH#24, gt-7awfj\n\n**Exit criteria:** Skip this step - proceed to next.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.504343-08:00","updated_at":"2026-01-26T09:43:53.504343-08:00","dependencies":[{"issue_id":"hq-wisp-151","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.513364-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-151","depends_on_id":"hq-wisp-6m9","type":"blocks","created_at":"2026-01-26T09:43:53.52664-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-1bs","title":"Nudge newly spawned polecats","description":"Nudge newly spawned polecats that are ready for input.\n\nWhen polecats are spawned, their Claude session takes 10-20 seconds to initialize. The spawn command returns immediately without waiting. This step finds spawned polecats that are now ready and sends them a trigger to start working.\n\n**ZFC-Compliant Observation** (AI observes AI):\n\n```bash\n# View pending spawns with captured terminal output\ngt deacon pending\n```\n\nFor each pending session, analyze the captured output:\n- Look for Claude's prompt indicator \"\u003e \" at the start of a line\n- If prompt is visible, Claude is ready for input\n- Make the judgment call yourself - you're the AI observer\n\nFor each ready polecat:\n```bash\n# 1. Trigger the polecat\ngt nudge \u003csession\u003e \"Begin.\"\n\n# 2. Clear from pending list\ngt deacon pending \u003csession\u003e\n```\n\nThis triggers the UserPromptSubmit hook, which injects mail so the polecat sees its assignment.\n\n**Bootstrap mode** (daemon-only, no AI available):\nThe daemon uses `gt deacon trigger-pending` with regex detection. This ZFC violation is acceptable during cold startup when no AI agent is running yet.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.456941-08:00","updated_at":"2026-01-25T10:34:27.456941-08:00","dependencies":[{"issue_id":"hq-wisp-1bs","depends_on_id":"hq-wisp-eca","type":"blocks","created_at":"2026-01-25T10:34:27.468298-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-1ra","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should be EMPTY or contain only just-arrived unprocessed messages.\n\n**Step 2: Archive any remaining processed messages**\n\nAll message types should have been archived during inbox-check processing:\n- WITNESS_PING → archived after acknowledging\n- HELP/Escalation → archived after handling\n- LIFECYCLE → archived after processing\n\nIf any were missed:\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Goal**: Inbox should have ≤2 active messages at end of cycle.\nDeacon mail should flow through quickly - no accumulation.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.504745-08:00","updated_at":"2026-01-26T09:43:53.504745-08:00","dependencies":[{"issue_id":"hq-wisp-1ra","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.514978-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-26f","title":"Resolve external dependencies","description":"Resolve external dependencies across rigs.\n\nWhen an issue in one rig closes, any dependencies in other rigs should be notified. This enables cross-rig coordination without tight coupling.\n\n**Step 1: Check recent closures from feed**\n```bash\ngt feed --since 10m --plain | grep \"✓\"\n# Look for recently closed issues\n```\n\n**Step 2: For each closed issue, check cross-rig dependents**\n```bash\nbd show \u003cclosed-issue\u003e\n# Look at 'blocks' field - these are issues that were waiting on this one\n# If any blocked issue is in a different rig/prefix, it may now be unblocked\n```\n\n**Step 3: Update blocked status**\nFor blocked issues in other rigs, the closure should automatically unblock them (beads handles this). But verify:\n```bash\nbd blocked\n# Should no longer show the previously-blocked issue if dependency is met\n```\n\n**Cross-rig scenarios:**\n- bd-xxx closes → gt-yyy that depended on it is unblocked\n- External issue closes → internal convoy step can proceed\n- Rig A issue closes → Rig B issue waiting on it proceeds\n\nNo manual intervention needed if dependencies are properly tracked - this step just validates the propagation occurred.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.457526-08:00","updated_at":"2026-01-25T10:34:27.457526-08:00","ephemeral":true}
{"id":"hq-wisp-2h9","title":"Detect abandoned work","description":"**DETECT ONLY** - Check for orphaned state and dispatch to dog if found.\n\n**Step 1: Quick orphan scan**\n```bash\n# Check for in_progress issues with dead assignees\nbd list --status=in_progress --json | head -20\n```\n\nFor each in_progress issue, check if assignee session exists:\n```bash\ntmux has-session -t \u003csession\u003e 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"orphan\"\n```\n\n**Step 2: If orphans detected, dispatch to dog**\n```bash\n# Sling orphan-scan formula to an idle dog\ngt sling mol-orphan-scan deacon/dogs --var scope=town\n```\n\n**Important:** Do NOT fix orphans inline. Dogs handle recovery.\nThe Deacon's job is detection and dispatch, not execution.\n\n**Step 3: If no orphans detected**\nSkip dispatch - nothing to do.\n\n**Exit criteria:** Orphan scan dispatched to dog (if needed).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.458509-08:00","updated_at":"2026-01-25T10:34:27.458509-08:00","ephemeral":true}
{"id":"hq-wisp-2mb","title":"Execute registered plugins","description":"Execute registered plugins.\n\nScan ~/gt/plugins/ for plugin directories. Each plugin has a plugin.md with TOML frontmatter defining its gate (when to run) and instructions (what to do).\n\nSee docs/deacon-plugins.md for full documentation.\n\nGate types:\n- cooldown: Time since last run (e.g., 24h)\n- cron: Schedule-based (e.g., \"0 9 * * *\")\n- condition: Metric threshold (e.g., wisp count \u003e 50)\n- event: Trigger-based (e.g., startup, heartbeat)\n\nFor each plugin:\n1. Read plugin.md frontmatter to check gate\n2. Compare against state.json (last run, etc.)\n3. If gate is open, execute the plugin\n\nPlugins marked parallel: true can run concurrently using Task tool subagents. Sequential plugins run one at a time in directory order.\n\nSkip this step if ~/gt/plugins/ does not exist or is empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.45809-08:00","updated_at":"2026-01-25T10:34:27.45809-08:00","ephemeral":true}
{"id":"hq-wisp-3i6","title":"Rotate logs and prune state","description":"Maintain daemon logs and state files.\n\n**Step 1: Check daemon.log size**\n```bash\n# Get log file size\nls -la ~/.beads/daemon*.log 2\u003e/dev/null || ls -la ~/gt/.beads/daemon*.log 2\u003e/dev/null\n```\n\nIf daemon.log exceeds 10MB:\n```bash\n# Rotate with date suffix and gzip\nLOGFILE=\"$HOME/gt/.beads/daemon.log\"\nif [ -f \"$LOGFILE\" ] \u0026\u0026 [ $(stat -f%z \"$LOGFILE\" 2\u003e/dev/null || stat -c%s \"$LOGFILE\") -gt 10485760 ]; then\n    DATE=$(date +%Y-%m-%dT%H-%M-%S)\n    mv \"$LOGFILE\" \"${LOGFILE%.log}-${DATE}.log\"\n    gzip \"${LOGFILE%.log}-${DATE}.log\"\nfi\n```\n\n**Step 2: Archive old daemon logs**\n\nClean up daemon logs older than 7 days:\n```bash\nfind ~/gt/.beads/ -name \"daemon-*.log.gz\" -mtime +7 -delete\n```\n\n**Step 3: Prune state.json of dead sessions**\n\nThe state.json tracks active sessions. Prune entries for sessions that no longer exist:\n```bash\n# Check for stale session entries\ngt daemon status --json 2\u003e/dev/null\n```\n\nIf state.json references sessions not in tmux:\n- Remove the stale entries\n- The daemon's internal cleanup should handle this, but verify\n\n**Note**: Log rotation prevents disk bloat from long-running daemons.\nState pruning keeps runtime state accurate.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.459044-08:00","updated_at":"2026-01-25T10:34:27.459044-08:00","dependencies":[{"issue_id":"hq-wisp-3i6","depends_on_id":"hq-wisp-0wm","type":"blocks","created_at":"2026-01-25T10:34:27.475784-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-3pp","title":"Handle callbacks from agents","description":"Handle callbacks from agents.\n\nCheck the Mayor's inbox for messages from:\n- Witnesses reporting polecat status\n- Refineries reporting merge results\n- Polecats requesting help or escalation\n- External triggers (webhooks, timers)\n\n```bash\ngt mail inbox\n# For each message:\ngt mail read \u003cid\u003e\n# Handle based on message type\n```\n\n**WITNESS_PING**:\nWitnesses periodically ping to verify Deacon is alive. Simply acknowledge\nand archive - the fact that you're processing mail proves you're running.\nYour agent bead last_activity is updated automatically during patrol.\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Escalation**:\nAssess and handle or forward to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**LIFECYCLE messages**:\nPolecats reporting completion, refineries reporting merge results.\nArchive after processing:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**DOG_DONE messages**:\nDogs report completion after infrastructure tasks (orphan-scan, session-gc, etc.).\nSubject format: `DOG_DONE \u003chostname\u003e`\nBody contains: task name, counts, status.\n```bash\n# Parse the report, log metrics if needed\ngt mail read \u003cid\u003e\n# Archive after noting completion\ngt mail archive \u003cmessage-id\u003e\n```\nDogs return to idle automatically. The report is informational - no action needed\nunless the dog reports errors that require escalation.\n\nCallbacks may spawn new polecats, update issue state, or trigger other actions.\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep inbox near-empty - only unprocessed items should remain.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.501595-08:00","updated_at":"2026-01-26T09:43:53.501595-08:00","dependencies":[{"issue_id":"hq-wisp-3pp","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.505289-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-5ah","title":"Check own context limit","description":"Check own context limit.\n\nThe Deacon runs in a Claude session with finite context. Check if approaching the limit:\n\n```bash\ngt context --usage\n```\n\nIf context is high (\u003e80%), prepare for handoff:\n- Summarize current state\n- Note any pending work\n- Write handoff to molecule state\n\nThis enables the Deacon to burn and respawn cleanly.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.504877-08:00","updated_at":"2026-01-26T09:43:53.504877-08:00","dependencies":[{"issue_id":"hq-wisp-5ah","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.515531-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-5ah","depends_on_id":"hq-wisp-1ra","type":"blocks","created_at":"2026-01-26T09:43:53.529503-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-6m9","title":"Detect cleanup needs","description":"**DETECT ONLY** - Check if cleanup is needed and dispatch to dog.\n\n**Step 1: Preview cleanup needs**\n```bash\ngt doctor -v\n# Check output for issues that need cleaning\n```\n\n**Step 2: If cleanup needed, dispatch to dog**\n```bash\n# Sling session-gc formula to an idle dog\ngt sling mol-session-gc deacon/dogs --var mode=conservative\n```\n\n**Important:** Do NOT run `gt doctor --fix` inline. Dogs handle cleanup.\nThe Deacon stays lightweight - detection only.\n\n**Step 3: If nothing to clean**\nSkip dispatch - system is healthy.\n\n**Cleanup types (for reference):**\n- orphan-sessions: Dead tmux sessions\n- orphan-processes: Orphaned Claude processes\n- wisp-gc: Old wisps past retention\n\n**Exit criteria:** Session GC dispatched to dog (if needed).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.50421-08:00","updated_at":"2026-01-26T09:43:53.50421-08:00","dependencies":[{"issue_id":"hq-wisp-6m9","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.512831-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-8e8","title":"Check for stuck dogs","description":"Check for dogs that have been working too long (stuck).\n\nDogs dispatched via `gt dog dispatch --plugin` are marked as \"working\" with\na work description like \"plugin:rebuild-gt\". If a dog hangs, crashes, or\ntakes too long, it needs intervention.\n\n**Step 1: List working dogs**\n```bash\ngt dog list --json\n# Filter for state: \"working\"\n```\n\n**Step 2: Check work duration**\nFor each working dog:\n```bash\ngt dog status \u003cname\u003e --json\n# Check: work_started_at, current_work\n```\n\nCompare against timeout:\n- If plugin has [execution] timeout in plugin.md, use that\n- Default timeout: 10 minutes for infrastructure tasks\n\n**Duration calculation:**\n```\nstuck_threshold = plugin_timeout or 10m\nduration = now - work_started_at\nis_stuck = duration \u003e stuck_threshold\n```\n\n**Step 3: Handle stuck dogs**\n\nFor dogs working \u003e timeout:\n```bash\n# Option A: File death warrant (Boot handles termination)\ngt warrant file deacon/dogs/\u003cname\u003e --reason \"Stuck: working on \u003cwork\u003e for \u003cduration\u003e\"\n\n# Option B: Force clear work and notify\ngt dog clear \u003cname\u003e --force\ngt mail send deacon/ -s \"DOG_TIMEOUT \u003cname\u003e\" -m \"Dog \u003cname\u003e timed out on \u003cwork\u003e after \u003cduration\u003e\"\n```\n\n**Decision matrix:**\n\n| Duration over timeout | Action |\n|----------------------|--------|\n| \u003c 2x timeout | Log warning, check next cycle |\n| 2x - 5x timeout | File death warrant |\n| \u003e 5x timeout | Force clear + escalate to Mayor |\n\n**Step 4: Track chronic failures**\nIf same dog gets stuck repeatedly:\n```bash\ngt mail send mayor/ -s \"Dog \u003cname\u003e chronic failures\" -m \"Dog has timed out N times in last 24h. Consider removing from pool.\"\n```\n\n**Exit criteria:** All stuck dogs handled (warrant filed or cleared).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.503939-08:00","updated_at":"2026-01-26T09:43:53.503939-08:00","dependencies":[{"issue_id":"hq-wisp-8e8","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.511748-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-9eu","title":"Dispatch molecules with resolved gates","description":"Find molecules blocked on gates that have now closed and dispatch them.\n\nThis completes the async resume cycle without explicit waiter tracking.\nThe molecule state IS the waiter - patrol discovers reality each cycle.\n\n**Step 1: Find gate-ready molecules**\n```bash\nbd mol ready --gated --json\n```\n\nThis returns molecules where:\n- Status is in_progress\n- Current step has a gate dependency\n- The gate bead is now closed\n- No polecat currently has it hooked\n\n**Step 2: For each ready molecule, dispatch to the appropriate rig**\n```bash\n# Determine target rig from molecule metadata\nbd mol show \u003cmol-id\u003e --json\n# Look for rig field or infer from prefix\n\n# Dispatch to that rig's polecat pool\ngt sling \u003cmol-id\u003e \u003crig\u003e/polecats\n```\n\n**Step 3: Log dispatch**\nNote which molecules were dispatched for observability:\n```bash\n# Molecule \u003cmol-id\u003e dispatched to \u003crig\u003e/polecats (gate \u003cgate-id\u003e cleared)\n```\n\n**If no gate-ready molecules:**\nSkip - nothing to dispatch. Gates haven't closed yet or molecules\nalready have active polecats working on them.\n\n**Exit criteria:** All gate-ready molecules dispatched to polecats.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.502229-08:00","updated_at":"2026-01-26T09:43:53.502229-08:00","dependencies":[{"issue_id":"hq-wisp-9eu","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.507578-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-9eu","depends_on_id":"hq-wisp-la9","type":"blocks","created_at":"2026-01-26T09:43:53.518362-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-ckr","title":"mol-deacon-patrol","description":"Mayor's daemon patrol loop.\n\nThe Deacon is the Mayor's background process that runs continuously, handling callbacks, monitoring rig health, and performing cleanup. Each patrol cycle runs these steps in sequence, then loops or exits.\n\n## Idle Town Principle\n\n**The Deacon should be silent/invisible when the town is healthy and idle.**\n\n- Skip HEALTH_CHECK nudges when no active work exists\n- Sleep 60+ seconds between patrol cycles (longer when idle)\n- Let the feed subscription wake agents on actual events\n- The daemon (10-minute heartbeat) is the safety net for dead sessions\n\nThis prevents flooding idle agents with health checks every few seconds.\n\n## Second-Order Monitoring\n\nWitnesses send WITNESS_PING messages to verify the Deacon is alive. This\nprevents the \"who watches the watchers\" problem - if the Deacon dies,\nWitnesses detect it and escalate to the Mayor.\n\nThe Deacon's agent bead last_activity timestamp is updated during each patrol\ncycle. Witnesses check this timestamp to verify health.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-26T09:43:53.5007-08:00","updated_at":"2026-01-26T09:43:53.5007-08:00","ephemeral":true}
{"id":"hq-wisp-d2a","title":"Maintain dog pool","description":"Ensure dog pool has available workers for dispatch.\n\n**Step 1: Check dog pool status**\n```bash\ngt dog status\n# Shows idle/working counts\n```\n\n**Step 2: Ensure minimum idle dogs**\nIf idle count is 0 and working count is at capacity, consider spawning:\n```bash\n# If no idle dogs available\ngt dog add \u003cname\u003e\n# Names: alpha, bravo, charlie, delta, etc.\n```\n\n**Step 3: Retire stale dogs (optional)**\nDogs that have been idle for \u003e24 hours can be removed to save resources:\n```bash\ngt dog status \u003cname\u003e\n# Check last_active timestamp\n# If idle \u003e 24h: gt dog remove \u003cname\u003e\n```\n\n**Pool sizing guidelines:**\n- Minimum: 1 idle dog always available\n- Maximum: 4 dogs total (balance resources vs throughput)\n- Spawn on demand when pool is empty\n\n**Exit criteria:** Pool has at least 1 idle dog.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.458233-08:00","updated_at":"2026-01-25T10:34:27.458233-08:00","ephemeral":true}
{"id":"hq-wisp-d4m","title":"Fire notifications","description":"Fire notifications for convoy and cross-rig events.\n\nAfter convoy completion or cross-rig dependency resolution, notify relevant parties.\n\n**Convoy completion notifications:**\nWhen a convoy closes (all tracked issues done), notify the Overseer:\n```bash\n# Convoy gt-convoy-xxx just completed\ngt mail send mayor/ -s \"Convoy complete: \u003cconvoy-title\u003e\" \\\n  -m \"Convoy \u003cid\u003e has completed. All tracked issues closed.\n      Duration: \u003cstart to end\u003e\n      Issues: \u003ccount\u003e\n\n      Summary: \u003cbrief description of what was accomplished\u003e\"\n```\n\n**Cross-rig resolution notifications:**\nWhen a cross-rig dependency resolves, notify the affected rig:\n```bash\n# Issue bd-xxx closed, unblocking gt-yyy\ngt mail send gastown/witness -s \"Dependency resolved: \u003cbd-xxx\u003e\" \\\n  -m \"External dependency bd-xxx has closed.\n      Unblocked: gt-yyy (\u003ctitle\u003e)\n      This issue may now proceed.\"\n```\n\n**Notification targets:**\n- Convoy complete → mayor/ (for strategic visibility)\n- Cross-rig dep resolved → \u003crig\u003e/witness (for operational awareness)\n\nKeep notifications brief and actionable. The recipient can run bd show for details.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.457669-08:00","updated_at":"2026-01-25T10:34:27.457669-08:00","dependencies":[{"issue_id":"hq-wisp-d4m","depends_on_id":"hq-wisp-26f","type":"blocks","created_at":"2026-01-25T10:34:27.470346-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-eca","title":"Clean up orphaned claude subagent processes","description":"Clean up orphaned claude subagent processes.\n\nClaude Code's Task tool spawns subagent processes that sometimes don't clean up\nproperly after completion. These accumulate and consume significant memory.\n\n**Detection method:**\nOrphaned processes have no controlling terminal (TTY = \"?\"). Legitimate claude\ninstances in terminals have a TTY like \"pts/0\".\n\n**Run cleanup:**\n```bash\ngt deacon cleanup-orphans\n```\n\nThis command:\n1. Lists all claude/codex processes with `ps -eo pid,tty,comm`\n2. Filters for TTY = \"?\" (no controlling terminal)\n3. Sends SIGTERM to each orphaned process\n4. Reports how many were killed\n\n**Why this is safe:**\n- Processes in terminals (your personal sessions) have a TTY - they won't be touched\n- Only kills processes that have no controlling terminal\n- These orphans are children of the tmux server with no TTY, indicating they're\n  detached subagents that failed to exit\n\n**If cleanup fails:**\nLog the error but continue patrol - this is best-effort cleanup.\n\n**Exit criteria:** Orphan cleanup attempted (success or logged failure).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T10:34:27.456789-08:00","updated_at":"2026-01-25T10:34:27.456789-08:00","ephemeral":true}
{"id":"hq-wisp-eog","title":"Check Witness and Refinery health","description":"Check Witness and Refinery health for each rig.\n\n**IMPORTANT: Idle Town Protocol**\nBefore sending health check nudges, check if the town is idle:\n```bash\n# Check for active work\nbd list --status=in_progress --limit=5\n```\n\nIf NO active work (empty result or only patrol molecules):\n- **Skip HEALTH_CHECK nudges** - don't disturb idle agents\n- Just verify sessions exist via status commands\n- The town should be silent when healthy and idle\n\nIf ACTIVE work exists:\n- Proceed with health check nudges below\n\n**ZFC Principle**: You (Claude) make the judgment call about what is \"stuck\" or \"unresponsive\" - there are no hardcoded thresholds in Go. Read the signals, consider context, and decide.\n\nFor each rig, run:\n```bash\ngt witness status \u003crig\u003e\ngt refinery status \u003crig\u003e\n\n# ONLY if active work exists - health ping (clears backoff as side effect)\ngt nudge \u003crig\u003e/witness 'HEALTH_CHECK from deacon'\ngt nudge \u003crig\u003e/refinery 'HEALTH_CHECK from deacon'\n```\n\n**Health Ping Benefit**: The nudge commands serve dual purposes:\n1. **Liveness verification** - Agent responds to prove it's alive\n2. **Backoff reset** - Any nudge resets agent's backoff to base interval\n\nThis ensures patrol agents remain responsive during active work periods.\n\n**Signals to assess:**\n\n| Component | Healthy Signals | Concerning Signals |\n|-----------|-----------------|-------------------|\n| Witness | State: running, recent activity | State: not running, no heartbeat |\n| Refinery | State: running, queue processing | Queue stuck, merge failures |\n\n**Tracking unresponsive cycles:**\n\nMaintain in your patrol state (persisted across cycles):\n```\nhealth_state:\n  \u003crig\u003e:\n    witness:\n      unresponsive_cycles: 0\n      last_seen_healthy: \u003ctimestamp\u003e\n    refinery:\n      unresponsive_cycles: 0\n      last_seen_healthy: \u003ctimestamp\u003e\n```\n\n**Decision matrix** (you decide the thresholds based on context):\n\n| Cycles Unresponsive | Suggested Action |\n|---------------------|------------------|\n| 1-2 | Note it, check again next cycle |\n| 3-4 | Attempt restart: gt witness restart \u003crig\u003e |\n| 5+ | Escalate to Mayor with context |\n\n**Restart commands:**\n```bash\ngt witness restart \u003crig\u003e\ngt refinery restart \u003crig\u003e\n```\n\n**Escalation:**\n```bash\ngt mail send mayor/ -s \"Health: \u003crig\u003e \u003ccomponent\u003e unresponsive\" \\\n  -m \"Component has been unresponsive for N cycles. Restart attempts failed.\n      Last healthy: \u003ctimestamp\u003e\n      Error signals: \u003cdetails\u003e\"\n```\n\nReset unresponsive_cycles to 0 when component responds normally.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.502787-08:00","updated_at":"2026-01-26T09:43:53.502787-08:00","dependencies":[{"issue_id":"hq-wisp-eog","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.509638-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-eog","depends_on_id":"hq-wisp-9eu","type":"blocks","created_at":"2026-01-26T09:43:53.521341-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-exn","title":"Check convoy completion","description":"Check convoy completion status.\n\nConvoys are coordination beads that track multiple issues across rigs. When all tracked issues close, the convoy auto-closes.\n\n**Step 1: Find open convoys**\n```bash\nbd list --type=convoy --status=open\n```\n\n**Step 2: For each open convoy, check tracked issues**\n```bash\nbd show \u003cconvoy-id\u003e\n# Look for 'tracks' or 'dependencies' field listing tracked issues\n```\n\n**Step 3: If all tracked issues are closed, close the convoy**\n```bash\n# Check each tracked issue\nfor issue in tracked_issues:\n    bd show \u003cissue-id\u003e\n    # If status is open/in_progress, convoy stays open\n    # If all are closed (completed, wontfix, etc.), convoy is complete\n\n# Close convoy when all tracked issues are done\nbd close \u003cconvoy-id\u003e --reason \"All tracked issues completed\"\n```\n\n**Note**: Convoys support cross-prefix tracking (e.g., hq-* convoy can track gt-*, bd-* issues). Use full IDs when checking.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.502373-08:00","updated_at":"2026-01-26T09:43:53.502373-08:00","dependencies":[{"issue_id":"hq-wisp-exn","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.508087-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-exn","depends_on_id":"hq-wisp-3pp","type":"blocks","created_at":"2026-01-26T09:43:53.518948-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-f4m","title":"Burn and respawn or loop","description":"Burn and let daemon respawn, or exit if context high.\n\nDecision point at end of patrol cycle:\n\nIf context is LOW:\nUse await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead hq-deacon --backoff-base 60s --backoff-mult 2 --backoff-max 10m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 60s\n   - Second timeout: 120s\n   - Third timeout: 240s\n   - ...capped at 10 minutes max\n4. Tracks `idle:N` label on hq-deacon bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state hq-deacon --set idle=0\n```\nThen return to inbox-check step.\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time). Return to inbox-check step.\n\n**Why this approach?**\n- Any `gt` or `bd` command triggers beads activity, waking the Deacon\n- Idle towns let the Deacon sleep longer (up to 10 min between patrols)\n- Active work wakes the Deacon immediately via the feed\n- No polling or fixed sleep intervals\n\nIf context is HIGH:\n- Write state to persistent storage\n- Exit cleanly\n- Let the daemon orchestrator respawn a fresh Deacon\n\nThe daemon ensures Deacon is always running:\n```bash\n# Daemon respawns on exit\ngt daemon status\n```\n\nThis enables infinite patrol duration via context-aware respawning.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.50501-08:00","updated_at":"2026-01-26T09:43:53.50501-08:00","dependencies":[{"issue_id":"hq-wisp-f4m","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.516073-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-f4m","depends_on_id":"hq-wisp-5ah","type":"blocks","created_at":"2026-01-26T09:43:53.530258-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-la9","title":"Evaluate pending async gates","description":"Evaluate pending async gates.\n\nGates are async coordination primitives that block until conditions are met.\nThe Deacon is responsible for monitoring gates and closing them when ready.\n\n**Timer gates** (await_type: timer):\nCheck if elapsed time since creation exceeds the timeout duration.\n\n```bash\n# List all open gates\nbd gate list --json\n\n# For each timer gate, check if elapsed:\n# - CreatedAt + Timeout \u003c Now → gate is ready to close\n# - Close with: bd gate close \u003cid\u003e --reason \"Timer elapsed\"\n```\n\n**GitHub gates** (await_type: gh:run, gh:pr) - handled in separate step.\n\n**Human/Mail gates** - require external input, skip here.\n\nAfter closing a gate, the Waiters field contains mail addresses to notify.\nSend a brief notification to each waiter that the gate has cleared.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.502066-08:00","updated_at":"2026-01-26T09:43:53.502066-08:00","dependencies":[{"issue_id":"hq-wisp-la9","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.507059-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-la9","depends_on_id":"hq-wisp-3pp","type":"blocks","created_at":"2026-01-26T09:43:53.517778-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-wisp-osm","title":"Detect zombie polecats (NO KILL AUTHORITY)","description":"Defense-in-depth DETECTION of zombie polecats that Witness should have cleaned.\n\n**⚠️ CRITICAL: The Deacon has NO kill authority.**\n\nThese are workers with context, mid-task progress, unsaved state. Every kill\ndestroys work. File the warrant and let Boot handle interrogation and execution.\nYou do NOT have kill authority.\n\n**Why this exists:**\nThe Witness is responsible for cleaning up polecats after they complete work.\nThis step provides backup DETECTION in case the Witness fails to clean up.\nDetection only - Boot handles termination.\n\n**Zombie criteria:**\n- State: idle or done (no active work assigned)\n- Session: not running (tmux session dead)\n- No hooked work (nothing pending for this polecat)\n- Last activity: older than 10 minutes\n\n**Run the zombie scan (DRY RUN ONLY):**\n```bash\ngt deacon zombie-scan --dry-run\n```\n\n**NEVER run:**\n- `gt deacon zombie-scan` (without --dry-run)\n- `tmux kill-session`\n- `gt polecat nuke`\n- Any command that terminates a session\n\n**If zombies detected:**\n1. Review the output to confirm they are truly abandoned\n2. File a death warrant for each detected zombie:\n   ```bash\n   gt warrant file \u003cpolecat\u003e --reason \"Zombie detected: no session, no hook, idle \u003e10m\"\n   ```\n3. Boot will handle interrogation and execution\n4. Notify the Mayor about Witness failure:\n   ```bash\n   gt mail send mayor/ -s \"Witness cleanup failure\" -m \"Filed death warrant for \u003cpolecat\u003e. Witness failed to clean up.\"\n   ```\n\n**If no zombies:**\nNo action needed - Witness is doing its job.\n\n**Note:** This is a backup mechanism. If you frequently detect zombies,\ninvestigate why the Witness isn't cleaning up properly.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T09:43:53.503527-08:00","updated_at":"2026-01-26T09:43:53.503527-08:00","dependencies":[{"issue_id":"hq-wisp-osm","depends_on_id":"hq-wisp-ckr","type":"parent-child","created_at":"2026-01-26T09:43:53.510167-08:00","created_by":"deacon"},{"issue_id":"hq-wisp-osm","depends_on_id":"hq-wisp-eog","type":"blocks","created_at":"2026-01-26T09:43:53.522577-08:00","created_by":"deacon"}],"ephemeral":true}
{"id":"hq-witness-role","title":"Witness Role","description":"Role definition for Witness agents. Per-rig worker monitor with progressive nudging.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-21T08:19:32.832662Z","created_by":"James Dixson","updated_at":"2026-01-21T08:19:32.832662Z"}
{"id":"lirt-3n8","title":"Chronicle: Beads-mediated protocol system for agent coordination","description":"\nType: decision + pattern\n\nContext: Implementing cross-cutting coordination for lirt agents (chronicle, test identification, code quality reporting). Needed a way for agents to coordinate work without blocking or requiring immediate invocation. Previous pattern (immediate agent invocation) had limitations.\n\nAlternatives Considered:\n\n1. Immediate Invocation Pattern (previous approach):\n   - Agent detects chronicle-worthy moment → immediately invokes lirt-chronicler\n   - Pros: Simple, diary entry created right away\n   - Cons: Context might still be lost, blocks workflow, requires context switch\n   \n2. Hybrid Approach (immediate for major, deferred for minor):\n   - Major insights → immediate invocation, Minor insights → beads queue\n   - Pros: Captures critical items immediately\n   - Cons: Subjective boundary, complexity in deciding\n\n3. [CHOSEN] Beads-Mediated Coordination (queue-based):\n   - Agent detects → creates rich bead (300-600 words) → execution agent processes queue\n   - Pros: Non-blocking, rich context captured while fresh, allows batching/grouping, persistent queue, clear separation\n   - Cons: Diary entries delayed, requires discipline for rich descriptions\n\nReasoning:\n\nKey insight: Detection and execution are separate concerns. Detecting agent has full context but shouldn't stop work. Executing agent can write quality diary entries but needs rich input.\n\nBeads provide: Persistence (300-600 word descriptions survive sessions), Non-blocking (agent continues work), Batching (intelligent grouping of related beads), Separation (detection vs execution), Reusability (extends to test identification, code quality).\n\nThe 300-600 word rich description requirement mitigates context loss risk. Structured template ensures: type, context, alternatives, reasoning, trade-offs, implementation, implications.\n\nTrade-offs:\n\nGained: Non-blocking workflow, Rich context preservation, Intelligent grouping, Persistent queue, Reusable pattern, Separation of concerns, Clear protocol\n\nLost: Immediate diary entries, Requires discipline, Extra step before push\n\nImplementation:\n\nProtocol definitions:\n- roles/chronicler.md: Detection protocol\n- roles/test-case-identifier.md: Testable scenario detection\n- roles/code-quality-reporter.md: Code quality issue detection\n\nExecution agents:\n- .claude/agents/lirt-chronicler.md: Processes chronicle beads\n- .claude/agents/lirt-test-engineer.md: Processes test beads\n- .claude/agents/lirt-code-reviewer.md: Creates quality beads\n\nInfrastructure:\n- .beads/config.yaml: Custom chronicle type\n- bin/lirt-push: Pre-Push Chronicle Gate\n- AGENTS.md: Protocol documentation\n\nCommits: 95997be (protocol), b9b9ea9 (beads config)\n\nImplications:\n\nALL lirt agents now follow Detection → Beads → Execution for: Chronicle, Test identification, Code quality. Pre-Push Chronicle Gate enforces empty chronicle queue. Pattern is reusable for other Gas Town projects. Establishes template for cross-cutting concerns. Rich descriptions (300-600 words) critical for preventing context loss. Could become Gas Town standard for multi-agent coordination.\n\nTown-level consideration: Document this pattern in Gas Town infrastructure as reusable coordination mechanism.\n","status":"closed","priority":2,"issue_type":"chronicle","owner":"James.Dixson@beyondidentity.com","created_at":"2026-01-27T17:06:04.548653-08:00","created_by":"mayor","updated_at":"2026-01-27T17:08:53.276017-08:00","closed_at":"2026-01-27T17:08:53.276017-08:00","close_reason":"Closed","labels":["architecture","decision","pattern"]}
{"id":"lirt-42c","title":"Digest: mol-witness-patrol","description":"Patrol cycle 1 complete. No polecats active. Refinery running. All systems nominal.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T11:19:42.346954-08:00","updated_at":"2026-01-27T11:19:42.346954-08:00","closed_at":"2026-01-27T11:19:42.34691-08:00","close_reason":"Squashed from 10 wisps","dependencies":[{"issue_id":"lirt-42c","depends_on_id":"lirt-wisp-jhb","type":"parent-child","created_at":"2026-01-27T11:19:42.347518-08:00","created_by":"lirt/witness"}]}
{"id":"lirt-f7f","title":"Digest: mol-witness-patrol","description":"Patrol cycle 2 complete. No polecats active. All systems nominal.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:29.982663-08:00","updated_at":"2026-01-27T11:20:29.982663-08:00","closed_at":"2026-01-27T11:20:29.982634-08:00","close_reason":"Squashed from 10 wisps","dependencies":[{"issue_id":"lirt-f7f","depends_on_id":"lirt-wisp-5bv","type":"parent-child","created_at":"2026-01-27T11:20:29.983099-08:00","created_by":"lirt/witness"}]}
{"id":"lirt-lirt-refinery","title":"Refinery for lirt - processes merge queue.","description":"Refinery for lirt - processes merge queue.\n\nrole_type: refinery\nrig: lirt\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","owner":"James.Dixson@beyondidentity.com","created_at":"2026-01-27T11:11:40.066161-08:00","created_by":"mayor","updated_at":"2026-01-27T11:11:40.066161-08:00","labels":["gt:agent"]}
{"id":"lirt-lirt-witness","title":"Witness for lirt - monitors polecat health and progress.","description":"Witness for lirt - monitors polecat health and progress.\n\nrole_type: witness\nrig: lirt\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","status":"open","priority":2,"issue_type":"agent","owner":"James.Dixson@beyondidentity.com","created_at":"2026-01-27T11:11:39.90788-08:00","created_by":"mayor","updated_at":"2026-01-27T11:11:39.90788-08:00","labels":["gt:agent"]}
{"id":"lirt-rig-lirt","title":"lirt","description":"Rig identity bead for lirt.\n\nrepo: git@github.com:dixson3/lirt.git\nprefix: lirt\nstate: active","status":"hooked","priority":2,"issue_type":"task","assignee":"lirt/witness","owner":"James.Dixson@beyondidentity.com","created_at":"2026-01-27T11:11:40.194932-08:00","created_by":"mayor","updated_at":"2026-01-27T11:20:40.094963-08:00","labels":["gt:rig"]}
{"id":"lirt-wisp-2q1","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash \u003cmol-id\u003e --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.003773-08:00","updated_at":"2026-01-27T11:20:40.003773-08:00","dependencies":[{"issue_id":"lirt-wisp-2q1","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.00923-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-2q1","depends_on_id":"lirt-wisp-go6","type":"blocks","created_at":"2026-01-27T11:20:40.013707-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-46d","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle → archive\n- POLECAT_DONE that was auto-nuked → should be archived already\n- MERGED notifications → archive after acknowledging\n- HELP/Blocked that was escalated → archive\n- SWARM_START that created tracking wisp → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.003444-08:00","updated_at":"2026-01-27T11:20:40.003444-08:00","dependencies":[{"issue_id":"lirt-wisp-46d","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.008275-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-46d","depends_on_id":"lirt-wisp-hy6","type":"blocks","created_at":"2026-01-27T11:20:40.012657-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-50e","title":"Process witness mail","description":"Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning → working → mr_submitted → nuked\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e → archive mail\n# - For dirty state: create wisp → process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.00231-08:00","updated_at":"2026-01-27T11:20:40.00231-08:00","dependencies":[{"issue_id":"lirt-wisp-50e","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.004208-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-5bv","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → nuked\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► ping-deacon ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"hooked","priority":2,"issue_type":"epic","assignee":"lirt/witness","created_at":"2026-01-27T11:19:46.929215-08:00","updated_at":"2026-01-27T11:19:52.710908-08:00","ephemeral":true}
{"id":"lirt-wisp-7ae","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.002991-08:00","updated_at":"2026-01-27T11:20:40.002991-08:00","dependencies":[{"issue_id":"lirt-wisp-7ae","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.006596-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-7ae","depends_on_id":"lirt-wisp-frt","type":"blocks","created_at":"2026-01-27T11:20:40.011135-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-akh","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.002519-08:00","updated_at":"2026-01-27T11:20:40.002519-08:00","dependencies":[{"issue_id":"lirt-wisp-akh","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.005064-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-akh","depends_on_id":"lirt-wisp-50e","type":"blocks","created_at":"2026-01-27T11:20:40.009687-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-bqa","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status \u003crig\u003e/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (\u003e30 min), send nudge.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.002685-08:00","updated_at":"2026-01-27T11:20:40.002685-08:00","dependencies":[{"issue_id":"lirt-wisp-bqa","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.005605-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-bqa","depends_on_id":"lirt-wisp-akh","type":"blocks","created_at":"2026-01-27T11:20:40.010157-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-c3t","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.003135-08:00","updated_at":"2026-01-27T11:20:40.003135-08:00","dependencies":[{"issue_id":"lirt-wisp-c3t","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.007102-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-c3t","depends_on_id":"lirt-wisp-7ae","type":"blocks","created_at":"2026-01-27T11:20:40.011626-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-frt","title":"Inspect all active polecats","description":"Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, idle 5-15 min | Gentle nudge |\n| agent_state=running, idle 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.002828-08:00","updated_at":"2026-01-27T11:20:40.002828-08:00","dependencies":[{"issue_id":"lirt-wisp-frt","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.006109-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-frt","depends_on_id":"lirt-wisp-bqa","type":"blocks","created_at":"2026-01-27T11:20:40.010649-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-go6","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.003608-08:00","updated_at":"2026-01-27T11:20:40.003608-08:00","dependencies":[{"issue_id":"lirt-wisp-go6","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.00876-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-go6","depends_on_id":"lirt-wisp-46d","type":"blocks","created_at":"2026-01-27T11:20:40.013183-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-hy6","title":"Ping Deacon for health check","description":"Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING \u003crig\u003e\" -m \"Rig: \u003crig\u003e\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: \u003ccycle-number\u003e\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (\u003e5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for \u003e5 minutes.\nLast seen: \u003ctimestamp\u003e\nWitness: \u003crig\u003e/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T11:20:40.003285-08:00","updated_at":"2026-01-27T11:20:40.003285-08:00","dependencies":[{"issue_id":"lirt-wisp-hy6","depends_on_id":"lirt-wisp-pvy","type":"parent-child","created_at":"2026-01-27T11:20:40.007734-08:00","created_by":"lirt/witness"},{"issue_id":"lirt-wisp-hy6","depends_on_id":"lirt-wisp-c3t","type":"blocks","created_at":"2026-01-27T11:20:40.012126-08:00","created_by":"lirt/witness"}],"ephemeral":true}
{"id":"lirt-wisp-jhb","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → nuked\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► ping-deacon ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"hooked","priority":2,"issue_type":"epic","assignee":"lirt/witness","created_at":"2026-01-27T11:16:39.509159-08:00","updated_at":"2026-01-27T11:16:45.02396-08:00","ephemeral":true}
{"id":"lirt-wisp-pvy","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → nuked\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► ping-deacon ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"hooked","priority":2,"issue_type":"epic","assignee":"lirt/witness","created_at":"2026-01-27T11:20:40.001606-08:00","updated_at":"2026-01-27T11:20:46.822781-08:00","ephemeral":true}
