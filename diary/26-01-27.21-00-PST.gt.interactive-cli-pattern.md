# Interactive vs Non-Interactive Command Pattern for CLI Tools

**Date**: 2026-01-27 21:00 PST
**Town**: gt
**Type**: decision + pattern
**Bead**: lirt-a8k

---

## The Decision

Dual-mode command design for sensitive input: interactive prompt when flag omitted, non-interactive when flag provided.

**Implementation in lirt auth login**:
- No `--api-key` flag → Prompt for API key with masked input
- `--api-key` flag present → Accept key from flag (non-interactive)

## The Problem

Need to support both human users (interactive terminal sessions) and automation/CI (scripts, pipelines) with the same command. These use cases have conflicting requirements:

- **Humans**: Want prompts, no flags to remember, no secrets in shell history
- **Automation**: Need non-interactive flags, scriptable, no hanging on stdin

## Alternatives Considered

**1. Flag-only (no prompts)**
- ✅ Simple implementation, predictable
- ❌ Poor UX for humans, keys visible in shell history
- Rejected: Optimizes for automation at expense of human UX

**2. Prompt-only (no flags)**
- ✅ Great human UX, no keys in shell history
- ❌ Impossible to script, breaks CI/CD workflows
- Rejected: Optimizes for humans at expense of automation

**3. Separate commands (login-interactive, login-script)**
- ✅ Clear intent, no mode detection
- ❌ Confusing UX, extra commands to document/maintain
- Rejected: Complexity without benefit

**4. Chosen: Dual-mode with flag override**
- Interactive by default (detect missing flag, prompt with masked input)
- Non-interactive when flag provided
- Best of both worlds ✅

## Implementation Pattern

```go
apiKey := authAPIKeyFlag
if apiKey == "" {
    // Interactive: prompt with masked input
    fmt.Print("Enter your Linear API key: ")
    keyBytes, err := term.ReadPassword(int(syscall.Stdin))
    apiKey = string(keyBytes)
}
// Proceed with apiKey from either source
```

**Key steps**:
1. Check for flag first (explicit always wins)
2. Fallback to interactive prompt if flag absent
3. Use `golang.org/x/term.ReadPassword` for secure input
4. Echo newline after password read (terminal state)
5. Clear error if user cancels (Ctrl+C)

## Security Considerations

**Interactive mode**:
- ✅ Key never in shell history
- ✅ Input masked on screen
- ✅ Validates before storage

**Non-interactive mode**:
- ⚠️ Key in `ps` output briefly (acceptable for CI)
- ✅ Validates before storage
- ✅ No prompt hangs in automation

**Both modes**:
- Credentials file 0600 permissions
- API key validated against Linear API before storage

## Trade-offs

**Gained**:
- ✅ Great human UX (no flags to remember)
- ✅ Scriptable (non-interactive mode)
- ✅ Follows CLI conventions (gh, aws, docker)
- ✅ No shell history pollution

**Lost**:
- ❌ Slightly more complex implementation
- ❌ Need password input library (`golang.org/x/term`)
- ❌ Mode detection logic

## Precedents

This pattern is well-established in modern CLIs:

- **gh auth login** (GitHub CLI): Prompts interactively or `--with-token` flag
- **aws configure** (AWS CLI): Prompts for keys
- **docker login**: Prompts for password
- **kubectl config set-credentials**: Accepts `--token` or prompts

Users expect this behavior in CLI tools.

## Anti-Patterns to Avoid

❌ **Reading from stdin without checking if it's a terminal**
- Hangs in scripts when no input available

❌ **Prompting even when flag provided**
- Annoying in automation, defeats purpose of flag

❌ **No way to provide input non-interactively**
- Breaks CI/CD pipelines completely

❌ **Echoing sensitive input to terminal**
- Security issue, defeats purpose of masking

## Pattern Applies To

This pattern should be used for:
- Any command accepting sensitive input (passwords, tokens, keys)
- Commands used by both humans and automation
- `lirt auth login` specifically
- Future lirt commands with sensitive input

**Example use cases**:
- Password authentication
- Token generation
- Secret provisioning
- Credential rotation

## Implications

**For lirt**:
- Future commands with sensitive input follow this pattern
- Document both modes in help text and docs
- Add `--quiet` flag support to suppress prompts in automation
- Consider stdin detection for piped input scenarios

**Philosophy established**: Optimize for human UX without sacrificing scriptability.

## Implementation

**File**: cmd/auth.go:44-52 (auth login command)
**Docs**: docs/AUTHENTICATION.md (documents both modes)
**Library**: golang.org/x/term v0.39.0

## Related Work

- docs/AUTHENTICATION.md: Documents interactive and non-interactive login
- cmd/auth.go: Implements the pattern

---

**Chronicle bead**: lirt-a8k
**Labels**: cli-ux, decision, pattern
